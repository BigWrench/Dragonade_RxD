; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61219.0 

	TITLE	X:\GitHub\Renegade\Dragonade_RxD\MemoryManager\FastAllocator.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@ ; `string'
PUBLIC	??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@ ; `string'
PUBLIC	??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@ ; `string'
EXTRN	__imp___wassert:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__free:PROC
;	COMDAT ??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@ DB 'F'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, 'A', 00H, 'l', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@ DB 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
CONST	SEGMENT
??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@ DB '('
	DB	00H, '(', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '_', 00H
	DB	't', 00H, ')', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 's'
	DB	00H, ' ', 00H, '%', 00H, ' ', 00H, 'P', 00H, 'L', 00H, 'A', 00H
	DB	'T', 00H, 'F', 00H, 'O', 00H, 'R', 00H, 'M', 00H, '_', 00H, 'M'
	DB	00H, 'E', 00H, 'M', 00H, 'O', 00H, 'R', 00H, 'Y', 00H, '_', 00H
	DB	'A', 00H, 'L', 00H, 'I', 00H, 'G', 00H, 'N', 00H, 'M', 00H, 'E'
	DB	00H, 'N', 00H, 'T', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
CONST	SEGMENT
??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@ DB 'x'
	DB	00H, ':', 00H, '\', 00H, 'g', 00H, 'i', 00H, 't', 00H, 'h', 00H
	DB	'u', 00H, 'b', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'e'
	DB	00H, 'g', 00H, 'a', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'd', 00H
	DB	'r', 00H, 'a', 00H, 'g', 00H, 'o', 00H, 'n', 00H, 'a', 00H, 'd'
	DB	00H, 'e', 00H, '_', 00H, 'r', 00H, 'x', 00H, 'd', 00H, '\', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H
	DB	'\', 00H, 'T', 00H, 'S', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, '.', 00H, 'h', 00H, 00H, 00H		; `string'
PUBLIC	?Pop@?$TSList@UChunk@FastFixedAllocator@@@@QAEPAUChunk@FastFixedAllocator@@XZ ; TSList<FastFixedAllocator::Chunk>::Pop
PUBLIC	?Push@?$TSList@UChunk@FastFixedAllocator@@@@QAEXPAUChunk@FastFixedAllocator@@@Z ; TSList<FastFixedAllocator::Chunk>::Push
PUBLIC	?Push@?$TSList@ULink@FastFixedAllocator@@@@QAEXPAULink@FastFixedAllocator@@@Z ; TSList<FastFixedAllocator::Link>::Push
PUBLIC	?Get_Allocator@FastAllocatorGeneral@@SAPAV1@XZ	; FastAllocatorGeneral::Get_Allocator
PUBLIC	??_FFastFixedAllocator@@QAEXXZ			; FastFixedAllocator::`default constructor closure'
PUBLIC	??0FastAllocatorGeneral@@QAE@XZ			; FastAllocatorGeneral::FastAllocatorGeneral
PUBLIC	?Init@FastFixedAllocator@@QAEXI@Z		; FastFixedAllocator::Init
PUBLIC	??0Chunk@FastFixedAllocator@@QAE@XZ		; FastFixedAllocator::Chunk::Chunk
PUBLIC	?Grow@FastFixedAllocator@@QAEXXZ		; FastFixedAllocator::Grow
PUBLIC	??1FastFixedAllocator@@QAE@XZ			; FastFixedAllocator::~FastFixedAllocator
PUBLIC	??1?$TSList@UChunk@FastFixedAllocator@@@@QAE@XZ	; TSList<FastFixedAllocator::Chunk>::~TSList<FastFixedAllocator::Chunk>
PUBLIC	??0?$TSList@UChunk@FastFixedAllocator@@@@QAE@XZ	; TSList<FastFixedAllocator::Chunk>::TSList<FastFixedAllocator::Chunk>
PUBLIC	??1?$TSList@ULink@FastFixedAllocator@@@@QAE@XZ	; TSList<FastFixedAllocator::Link>::~TSList<FastFixedAllocator::Link>
PUBLIC	??0?$TSList@ULink@FastFixedAllocator@@@@QAE@XZ	; TSList<FastFixedAllocator::Link>::TSList<FastFixedAllocator::Link>
PUBLIC	??0FastFixedAllocator@@QAE@I@Z			; FastFixedAllocator::FastFixedAllocator
PUBLIC	??3SystemAllocatedClass@@SAXPAX@Z		; SystemAllocatedClass::operator delete
PUBLIC	??2SystemAllocatedClass@@SAPAXI@Z		; SystemAllocatedClass::operator new
PUBLIC	?SystemFree@SystemAllocatedClass@@KAXPAX@Z	; SystemAllocatedClass::SystemFree
PUBLIC	?SystemAllocate@SystemAllocatedClass@@KAPAXI@Z	; SystemAllocatedClass::SystemAllocate
PUBLIC	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ	; _TSListBase32::Pop
PUBLIC	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z	; _TSListBase32::Push
PUBLIC	??1_TSListBase32@@QAE@XZ			; _TSListBase32::~_TSListBase32
PUBLIC	??0_TSListBase32@@QAE@XZ			; _TSListBase32::_TSListBase32
PUBLIC	??0_TSLHead32@@QAE@XZ				; _TSLHead32::_TSLHead32
PUBLIC	??0_TSLNode32@@QAE@XZ				; _TSLNode32::_TSLNode32
PUBLIC	?YieldThread@@YAXXZ				; YieldThread
PUBLIC	?SystemFree@@YAXPAX@Z				; SystemFree
PUBLIC	?SystemAllocate@@YAPAXI@Z			; SystemAllocate
___general_allocator DD 01H DUP (?)
_BSS	ENDS
CRT$XCL	SEGMENT
___general_allocator$initializer$ DD FLAT:??__E__general_allocator@@YAXXZ
CRT$XCL	ENDS
CRT$XCL	ENDS
CRT$XCL	ENDS
CRT$XCL	ENDS
CRT$XCL	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
;	COMDAT ?SystemAllocate@@YAPAXI@Z
_TEXT	SEGMENT
?SystemAllocate@@YAPAXI@Z PROC				; SystemAllocate, COMDAT
; _size$ = ecx

; 27   : {

	push	esi

; 28   : 	void* memory = malloc(size);

	push	ecx
	call	DWORD PTR __imp__malloc
	mov	esi, eax
	add	esp, 4

; 29   : 	// If you hit this assert, you've run out of memory. This is bad.
; 30   : 	assert(memory);

	test	esi, esi
	jne	SHORT $LN3@SystemAllo
	push	30					; 0000001eH
	push	OFFSET ??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH

; 31   : 	return memory;

	mov	eax, esi
$LN3@SystemAllo:
	pop	esi

; 32   : };

	ret	0
?SystemAllocate@@YAPAXI@Z ENDP				; SystemAllocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
;	COMDAT ?SystemFree@@YAXPAX@Z
_TEXT	SEGMENT
?SystemFree@@YAXPAX@Z PROC				; SystemFree, COMDAT
; _memory$ = ecx

; 36   : 	free(memory);

	push	ecx
	call	DWORD PTR __imp__free
	pop	ecx

; 37   : };

	ret	0
?SystemFree@@YAXPAX@Z ENDP				; SystemFree
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
;	COMDAT ?YieldThread@@YAXXZ
_TEXT	SEGMENT
?YieldThread@@YAXXZ PROC				; YieldThread, COMDAT

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
	ret	0
?YieldThread@@YAXXZ ENDP				; YieldThread
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ??0_TSLNode32@@QAE@XZ
_TEXT	SEGMENT
??0_TSLNode32@@QAE@XZ PROC				; _TSLNode32::_TSLNode32, COMDAT
; _this$ = ecx

; 43   : 	{
; 44   : 		Next = 0;

	mov	DWORD PTR [ecx], 0

; 45   : 	};

	mov	eax, ecx
	ret	0
??0_TSLNode32@@QAE@XZ ENDP				; _TSLNode32::_TSLNode32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ??0_TSLHead32@@QAE@XZ
_TEXT	SEGMENT
??0_TSLHead32@@QAE@XZ PROC				; _TSLHead32::_TSLHead32, COMDAT
; _this$ = ecx

; 60   : 	TSLHead()

	push	ebx
	mov	ebx, ecx

; 61   : 	{
; 62   : 		Value = 0;

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	bl, 7
	je	SHORT $LN4@TSLHead32
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN4@TSLHead32:

; 64   : 	};

	mov	eax, ebx
	pop	ebx
	ret	0
??0_TSLHead32@@QAE@XZ ENDP				; _TSLHead32::_TSLHead32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ??0_TSListBase32@@QAE@XZ
_TEXT	SEGMENT
??0_TSListBase32@@QAE@XZ PROC				; _TSListBase32::_TSListBase32, COMDAT
; _this$ = ecx

; 73   : 	{

	push	ebx
	mov	ebx, ecx

; 62   : 		Value = 0;

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	bl, 7
	je	SHORT $LN6@TSListBase
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN6@TSListBase:

; 74   : 
; 75   : 	};

	mov	eax, ebx
	pop	ebx
	ret	0
??0_TSListBase32@@QAE@XZ ENDP				; _TSListBase32::_TSListBase32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ??1_TSListBase32@@QAE@XZ
_TEXT	SEGMENT
??1_TSListBase32@@QAE@XZ PROC				; _TSListBase32::~_TSListBase32, COMDAT
; _this$dead$ = ecx

; 79   : 
; 80   : 	};

	ret	0
??1_TSListBase32@@QAE@XZ ENDP				; _TSListBase32::~_TSListBase32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
_old_head$2$ = -24					; size = 4
_old_head$4$ = -16					; size = 4
_old_head$3$ = -16					; size = 4
_old_head$ = -16					; size = 8
_new_head$ = -8						; size = 8
_node$ = 8						; size = 4
?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z PROC	; _TSListBase32::Push, COMDAT
; _this$ = ecx

; 88   : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	lea	eax, DWORD PTR _old_head$[esp+36]

; 88   : 	{

	mov	esi, ecx
	push	edi

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	mov	edi, DWORD PTR __imp___wassert

; 88   : 	{

	mov	DWORD PTR _this$1$[esp+40], esi

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	al, 7
	je	SHORT $LN8@Push
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	edi
	add	esp, 12					; 0000000cH
$LN8@Push:
	lea	eax, DWORD PTR _new_head$[esp+40]
	xorps	xmm0, xmm0

; 62   : 		Value = 0;

	movlpd	QWORD PTR _new_head$[esp+40], xmm0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	al, 7
	je	SHORT $LN15@Push
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	edi
	add	esp, 12					; 0000000cH
$LN15@Push:

; 94   : 			old_head.Value = head.Value;

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]

; 95   : 			node->Next = old_head.Next;

	mov	edi, DWORD PTR _node$[ebp]
	mov	DWORD PTR _old_head$2$[esp+40], eax
	mov	DWORD PTR _old_head$3$[esp+40], edx
	mov	DWORD PTR [edi], eax

; 96   : 			new_head.Next = node;
; 97   : 			*((unsigned long *)&new_head.Depth) = *((unsigned long *)&old_head.Depth) + 0x10001; // increment depth + sequence at the same time

	lea	ecx, DWORD PTR [edx+65537]

; 98   : 			
; 99   : 			if (_InterlockedCompareExchange64(&head.Value, new_head.Value, old_head.Value) == old_head.Value) 

	mov	ebx, edi
	lock	 cmpxchg8b QWORD PTR [esi]
	mov	ecx, DWORD PTR _old_head$2$[esp+40]
	cmp	eax, ecx
	jne	SHORT $LN3@Push
	cmp	edx, DWORD PTR _old_head$3$[esp+40]
	jne	SHORT $LN3@Push

; 100  : 			{
; 101  : 				break;
; 102  : 			};
; 103  : 
; 104  : 			YieldThread();
; 105  : 		};
; 106  : 
; 107  : 		return old_head.Next;

	mov	eax, ecx

; 108  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	6
$LL21@Push:
	mov	esi, DWORD PTR _this$1$[esp+40]
$LN3@Push:
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 94   : 			old_head.Value = head.Value;

	mov	edi, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+4]

; 95   : 			node->Next = old_head.Next;

	mov	eax, DWORD PTR _node$[ebp]
	mov	DWORD PTR _old_head$4$[esp+40], esi
	mov	DWORD PTR [eax], edi

; 96   : 			new_head.Next = node;
; 97   : 			*((unsigned long *)&new_head.Depth) = *((unsigned long *)&old_head.Depth) + 0x10001; // increment depth + sequence at the same time

	lea	ecx, DWORD PTR [esi+65537]

; 98   : 			
; 99   : 			if (_InterlockedCompareExchange64(&head.Value, new_head.Value, old_head.Value) == old_head.Value) 

	mov	eax, edi
	mov	edx, esi
	mov	ebx, DWORD PTR _node$[ebp]
	mov	esi, DWORD PTR _this$1$[esp+40]
	lock	 cmpxchg8b QWORD PTR [esi]
	mov	esi, DWORD PTR _old_head$4$[esp+40]
	cmp	eax, edi
	jne	SHORT $LL21@Push
	cmp	edx, esi
	mov	esi, DWORD PTR _this$1$[esp+40]
	jne	SHORT $LN3@Push

; 100  : 			{
; 101  : 				break;
; 102  : 			};
; 103  : 
; 104  : 			YieldThread();
; 105  : 		};
; 106  : 
; 107  : 		return old_head.Next;

	mov	eax, edi

; 108  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ENDP	; _TSListBase32::Push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ
_TEXT	SEGMENT
_old_head$2$ = -16					; size = 4
_old_head$ = -16					; size = 8
_new_head$ = -8						; size = 8
?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ PROC		; _TSListBase32::Pop, COMDAT
; _this$ = ecx

; 111  : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 20					; 00000014H

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	lea	eax, DWORD PTR _old_head$[esp+20]

; 111  : 	{

	push	ebx
	push	esi
	push	edi

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	mov	edi, DWORD PTR __imp___wassert

; 111  : 	{

	mov	esi, ecx

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	al, 7
	je	SHORT $LN9@Pop
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	edi
	add	esp, 12					; 0000000cH
$LN9@Pop:
	lea	eax, DWORD PTR _new_head$[esp+32]
	xorps	xmm0, xmm0

; 62   : 		Value = 0;

	movlpd	QWORD PTR _new_head$[esp+32], xmm0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	al, 7
	je	SHORT $LN16@Pop
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	edi
	add	esp, 12					; 0000000cH
$LN16@Pop:

; 117  : 			old_head.Value = head.Value;

	mov	edi, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _old_head$2$[esp+32], edx

; 118  : 			if (!old_head.Next) 

	test	edi, edi
	je	SHORT $LN17@Pop
	npad	4
$LL4@Pop:

; 121  : 			}
; 122  : 
; 123  : 			new_head.Next = old_head.Next->Next;
; 124  : 			*((unsigned long *)&new_head.Depth) = *((unsigned long *)&old_head.Depth) - 1;

	lea	ecx, DWORD PTR [edx-1]

; 125  : 			
; 126  : 			if (_InterlockedCompareExchange64(&head.Value, new_head.Value, old_head.Value) == old_head.Value) 

	mov	eax, edi
	mov	ebx, DWORD PTR [edi]
	lock	 cmpxchg8b QWORD PTR [esi]
	cmp	eax, edi
	jne	SHORT $LN21@Pop
	cmp	edx, DWORD PTR _old_head$2$[esp+32]
	je	SHORT $LN18@Pop
$LN21@Pop:
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 117  : 			old_head.Value = head.Value;

	mov	edi, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _old_head$2$[esp+32], edx

; 118  : 			if (!old_head.Next) 

	test	edi, edi
	jne	SHORT $LL4@Pop
$LN17@Pop:

; 119  : 			{
; 120  : 				return NULL;

	xor	eax, eax

; 135  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@Pop:

; 127  : 			{
; 128  : 				break;
; 129  : 			};
; 130  : 
; 131  : 			YieldThread();
; 132  : 		};
; 133  : 
; 134  : 		return old_head.Next;

	mov	eax, edi

; 135  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ENDP		; _TSListBase32::Pop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?SystemAllocate@SystemAllocatedClass@@KAPAXI@Z
_TEXT	SEGMENT
?SystemAllocate@SystemAllocatedClass@@KAPAXI@Z PROC	; SystemAllocatedClass::SystemAllocate, COMDAT
; _size$ = ecx

; 36   : 	{

	push	esi
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 28   : 	void* memory = malloc(size);

	push	ecx
	call	DWORD PTR __imp__malloc
	mov	esi, eax
	add	esp, 4

; 29   : 	// If you hit this assert, you've run out of memory. This is bad.
; 30   : 	assert(memory);

	test	esi, esi
	jne	SHORT $LN5@SystemAllo
	push	30					; 0000001eH
	push	OFFSET ??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 37   : 		return ::SystemAllocate(size);

	mov	eax, esi
$LN5@SystemAllo:
	pop	esi

; 38   : 	};

	ret	0
?SystemAllocate@SystemAllocatedClass@@KAPAXI@Z ENDP	; SystemAllocatedClass::SystemAllocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?SystemFree@SystemAllocatedClass@@KAXPAX@Z
_TEXT	SEGMENT
?SystemFree@SystemAllocatedClass@@KAXPAX@Z PROC		; SystemAllocatedClass::SystemFree, COMDAT
; _memory$ = ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 36   : 	free(memory);

	push	ecx
	call	DWORD PTR __imp__free
	pop	ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 42   : 	};

	ret	0
?SystemFree@SystemAllocatedClass@@KAXPAX@Z ENDP		; SystemAllocatedClass::SystemFree
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ??2SystemAllocatedClass@@SAPAXI@Z
_TEXT	SEGMENT
??2SystemAllocatedClass@@SAPAXI@Z PROC			; SystemAllocatedClass::operator new, COMDAT
; _size$ = ecx

; 45   : 	{ 

	push	esi
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 28   : 	void* memory = malloc(size);

	push	ecx
	call	DWORD PTR __imp__malloc
	mov	esi, eax
	add	esp, 4

; 29   : 	// If you hit this assert, you've run out of memory. This is bad.
; 30   : 	assert(memory);

	test	esi, esi
	jne	SHORT $LN7@operator
	push	30					; 0000001eH
	push	OFFSET ??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 46   : 		return SystemAllocate(size); 

	mov	eax, esi
$LN7@operator:
	pop	esi

; 47   : 	};

	ret	0
??2SystemAllocatedClass@@SAPAXI@Z ENDP			; SystemAllocatedClass::operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ??3SystemAllocatedClass@@SAXPAX@Z
_TEXT	SEGMENT
??3SystemAllocatedClass@@SAXPAX@Z PROC			; SystemAllocatedClass::operator delete, COMDAT
; _memory$ = ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 36   : 	free(memory);

	push	ecx
	call	DWORD PTR __imp__free
	pop	ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 52   : 	};

	ret	0
??3SystemAllocatedClass@@SAXPAX@Z ENDP			; SystemAllocatedClass::operator delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ??0FastFixedAllocator@@QAE@I@Z
_TEXT	SEGMENT
_element_size$dead$ = 8					; size = 4
??0FastFixedAllocator@@QAE@I@Z PROC			; FastFixedAllocator::FastFixedAllocator, COMDAT
; _this$ = ecx

; 103  : {

	push	ebx
	mov	ebx, ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 62   : 		Value = 0;

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	bl, 7
	je	SHORT $LN9@FastFixedA
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN9@FastFixedA:

; 64   : 	};
; 65   : };
; 66   : 
; 67   : class _TSListBase32
; 68   : {
; 69   : private:
; 70   : 	TSLHead head;
; 71   : public:
; 72   : 	_TSListBase32(): head()
; 73   : 	{

	lea	eax, DWORD PTR [ebx+8]

; 62   : 		Value = 0;

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	al, 7
	je	SHORT $LN16@FastFixedA
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN16@FastFixedA:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 103  : {

	mov	DWORD PTR [ebx+20], 0
	mov	DWORD PTR [ebx+24], 0
	mov	DWORD PTR [ebx+28], 0

; 106  : 
; 107  : inline FastFixedAllocator::~FastFixedAllocator() // *not* thread safe
; 108  : {
; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())
; 110  : 	{
; 111  : 		delete n;
; 112  : 	};
; 113  : };
; 114  : 
; 115  : inline void FastFixedAllocator::Grow()
; 116  : {
; 117  : 	Chunk* n = new Chunk;
; 118  : 	Chunks.Push(n);
; 119  : 
; 120  : #ifdef FASTALLOC_STATS
; 121  : 	_InterlockedExchangeAdd((long *)&TotalHeapSize, sizeof(Chunk));
; 122  : #endif
; 123  : 
; 124  : 	const size_t number_elements = Chunk::size / ElementSize;
; 125  : 
; 126  : 	for (size_t i = 0; i < number_elements; ++i)
; 127  : 	{
; 128  : 		Link* link = (Link*)(n->Memory + (i * ElementSize) );
; 129  : 		link->Next = 0;
; 130  : 		FreeList.Push(link);
; 131  : 	};
; 132  : };
; 133  : 
; 134  : inline void FastFixedAllocator::Init(size_t element_size)
; 135  : {
; 136  : 	this->ElementSize = element_size < sizeof(Link) ? sizeof (Link) : element_size;

	mov	DWORD PTR [ebx+16], 8

; 104  : 	Init(element_size);
; 105  : };

	mov	eax, ebx
	pop	ebx
	ret	4
??0FastFixedAllocator@@QAE@I@Z ENDP			; FastFixedAllocator::FastFixedAllocator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ??0?$TSList@ULink@FastFixedAllocator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$TSList@ULink@FastFixedAllocator@@@@QAE@XZ PROC	; TSList<FastFixedAllocator::Link>::TSList<FastFixedAllocator::Link>, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, ecx

; 62   : 		Value = 0;

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	bl, 7
	je	SHORT $LN8@TSList
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN8@TSList:
	mov	eax, ebx
	pop	ebx
	ret	0
??0?$TSList@ULink@FastFixedAllocator@@@@QAE@XZ ENDP	; TSList<FastFixedAllocator::Link>::TSList<FastFixedAllocator::Link>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$TSList@ULink@FastFixedAllocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TSList@ULink@FastFixedAllocator@@@@QAE@XZ PROC	; TSList<FastFixedAllocator::Link>::~TSList<FastFixedAllocator::Link>, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$TSList@ULink@FastFixedAllocator@@@@QAE@XZ ENDP	; TSList<FastFixedAllocator::Link>::~TSList<FastFixedAllocator::Link>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ??0?$TSList@UChunk@FastFixedAllocator@@@@QAE@XZ
_TEXT	SEGMENT
??0?$TSList@UChunk@FastFixedAllocator@@@@QAE@XZ PROC	; TSList<FastFixedAllocator::Chunk>::TSList<FastFixedAllocator::Chunk>, COMDAT
; _this$ = ecx
	push	ebx
	mov	ebx, ecx

; 62   : 		Value = 0;

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	bl, 7
	je	SHORT $LN8@TSList
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN8@TSList:
	mov	eax, ebx
	pop	ebx
	ret	0
??0?$TSList@UChunk@FastFixedAllocator@@@@QAE@XZ ENDP	; TSList<FastFixedAllocator::Chunk>::TSList<FastFixedAllocator::Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$TSList@UChunk@FastFixedAllocator@@@@QAE@XZ
_TEXT	SEGMENT
??1?$TSList@UChunk@FastFixedAllocator@@@@QAE@XZ PROC	; TSList<FastFixedAllocator::Chunk>::~TSList<FastFixedAllocator::Chunk>, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$TSList@UChunk@FastFixedAllocator@@@@QAE@XZ ENDP	; TSList<FastFixedAllocator::Chunk>::~TSList<FastFixedAllocator::Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ??1FastFixedAllocator@@QAE@XZ
_TEXT	SEGMENT
??1FastFixedAllocator@@QAE@XZ PROC			; FastFixedAllocator::~FastFixedAllocator, COMDAT
; _this$ = ecx

; 108  : {

	push	esi

; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())

	lea	esi, DWORD PTR [ecx+8]
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 308  : 		return (T*) TSListBase::Pop();

	mov	ecx, esi
	call	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())

	test	eax, eax
	je	SHORT $LN1@FastFixedA
	push	edi
	mov	edi, DWORD PTR __imp__free
$LL3@FastFixedA:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 36   : 	free(memory);

	push	eax
	call	edi
	add	esp, 4
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 308  : 		return (T*) TSListBase::Pop();

	mov	ecx, esi
	call	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())

	test	eax, eax
	jne	SHORT $LL3@FastFixedA
	pop	edi
$LN1@FastFixedA:
	pop	esi

; 110  : 	{
; 111  : 		delete n;
; 112  : 	};
; 113  : };

	ret	0
??1FastFixedAllocator@@QAE@XZ ENDP			; FastFixedAllocator::~FastFixedAllocator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?Grow@FastFixedAllocator@@QAEXXZ
_TEXT	SEGMENT
?Grow@FastFixedAllocator@@QAEXXZ PROC			; FastFixedAllocator::Grow, COMDAT
; _this$ = ecx

; 116  : {

	push	ebx
	push	ebp
	push	esi
	push	edi
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 28   : 	void* memory = malloc(size);

	push	32768					; 00008000H
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 116  : {

	mov	ebx, ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 28   : 	void* memory = malloc(size);

	call	DWORD PTR __imp__malloc
	mov	edi, eax
	add	esp, 4

; 29   : 	// If you hit this assert, you've run out of memory. This is bad.
; 30   : 	assert(memory);

	test	edi, edi
	jne	SHORT $LN26@Grow
	push	30					; 0000001eH
	push	OFFSET ??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 117  : 	Chunk* n = new Chunk;

	jmp	SHORT $LN7@Grow
$LN26@Grow:
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 44   : 		Next = 0;

	mov	DWORD PTR [edi], 0
$LN7@Grow:

; 303  : 		TSListBase::Push((TSLNode*) item); 

	push	edi
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 118  : 	Chunks.Push(n);

	lea	ecx, DWORD PTR [ebx+8]
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	call	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 121  : 	_InterlockedExchangeAdd((long *)&TotalHeapSize, sizeof(Chunk));

	mov	ecx, 32768				; 00008000H
	lea	eax, DWORD PTR [ebx+20]
	lock	 xadd	 DWORD PTR [eax], ecx

; 122  : #endif
; 123  : 
; 124  : 	const size_t number_elements = Chunk::size / ElementSize;

	xor	edx, edx
	mov	eax, 32760				; 00007ff8H
	div	DWORD PTR [ebx+16]

; 126  : 	for (size_t i = 0; i < number_elements; ++i)

	xor	esi, esi
	mov	ebp, eax
	test	ebp, ebp
	je	SHORT $LN1@Grow
	npad	2
$LL3@Grow:

; 127  : 	{
; 128  : 		Link* link = (Link*)(n->Memory + (i * ElementSize) );

	mov	ecx, DWORD PTR [ebx+16]
	imul	ecx, esi
	add	ecx, 8
	add	ecx, edi
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	push	ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 129  : 		link->Next = 0;

	mov	DWORD PTR [ecx], 0
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	mov	ecx, ebx
	call	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 126  : 	for (size_t i = 0; i < number_elements; ++i)

	inc	esi
	cmp	esi, ebp
	jb	SHORT $LL3@Grow
$LN1@Grow:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 130  : 		FreeList.Push(link);
; 131  : 	};
; 132  : };

	ret	0
?Grow@FastFixedAllocator@@QAEXXZ ENDP			; FastFixedAllocator::Grow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ??0Chunk@FastFixedAllocator@@QAE@XZ
_TEXT	SEGMENT
??0Chunk@FastFixedAllocator@@QAE@XZ PROC		; FastFixedAllocator::Chunk::Chunk, COMDAT
; _this$ = ecx

; 44   : 		Next = 0;

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0Chunk@FastFixedAllocator@@QAE@XZ ENDP		; FastFixedAllocator::Chunk::Chunk
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?Init@FastFixedAllocator@@QAEXI@Z
_TEXT	SEGMENT
_element_size$ = 8					; size = 4
?Init@FastFixedAllocator@@QAEXI@Z PROC			; FastFixedAllocator::Init, COMDAT
; _this$ = ecx

; 136  : 	this->ElementSize = element_size < sizeof(Link) ? sizeof (Link) : element_size;

	mov	eax, DWORD PTR _element_size$[esp-4]
	mov	edx, 8
	cmp	eax, edx
	cmovb	eax, edx
	mov	DWORD PTR [ecx+16], eax

; 137  : };

	ret	4
?Init@FastFixedAllocator@@QAEXI@Z ENDP			; FastFixedAllocator::Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ??0FastAllocatorGeneral@@QAE@XZ
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
??0FastAllocatorGeneral@@QAE@XZ PROC			; FastAllocatorGeneral::FastAllocatorGeneral, COMDAT
; _this$ = ecx

; 210  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __imp___wassert
	mov	ebp, ecx
	push	edi
	mov	DWORD PTR _this$1$[esp+20], ebp
	mov	edi, 10					; 0000000aH
	lea	ebx, DWORD PTR [ebp+8]
	npad	7
$LL7@FastAlloca:
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 62   : 		Value = 0;

	mov	DWORD PTR [ebx-8], 0
	mov	DWORD PTR [ebx-4], 0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	bl, 7
	je	SHORT $LN20@FastAlloca
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	esi
	add	esp, 12					; 0000000cH
$LN20@FastAlloca:

; 62   : 		Value = 0;

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	bl, 7
	je	SHORT $LN27@FastAlloca
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	esi
	add	esp, 12					; 0000000cH
$LN27@FastAlloca:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 103  : {

	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+20], 0

; 104  : 	Init(element_size);
; 105  : };
; 106  : 
; 107  : inline FastFixedAllocator::~FastFixedAllocator() // *not* thread safe
; 108  : {
; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())
; 110  : 	{
; 111  : 		delete n;
; 112  : 	};
; 113  : };
; 114  : 
; 115  : inline void FastFixedAllocator::Grow()
; 116  : {
; 117  : 	Chunk* n = new Chunk;
; 118  : 	Chunks.Push(n);
; 119  : 
; 120  : #ifdef FASTALLOC_STATS
; 121  : 	_InterlockedExchangeAdd((long *)&TotalHeapSize, sizeof(Chunk));
; 122  : #endif
; 123  : 
; 124  : 	const size_t number_elements = Chunk::size / ElementSize;
; 125  : 
; 126  : 	for (size_t i = 0; i < number_elements; ++i)
; 127  : 	{
; 128  : 		Link* link = (Link*)(n->Memory + (i * ElementSize) );
; 129  : 		link->Next = 0;
; 130  : 		FreeList.Push(link);
; 131  : 	};
; 132  : };
; 133  : 
; 134  : inline void FastFixedAllocator::Init(size_t element_size)
; 135  : {
; 136  : 	this->ElementSize = element_size < sizeof(Link) ? sizeof (Link) : element_size;

	mov	DWORD PTR [ebx+8], 8
	add	ebx, 32					; 00000020H
	dec	edi
	jns	SHORT $LL7@FastAlloca

; 211  : 	for (int i = 0; i < NUM_ALLOCATORS; ++i)

	mov	esi, 1
	mov	DWORD PTR [ebp+352], 0
	mov	DWORD PTR [ebp+356], 0
	mov	DWORD PTR [ebp+360], 0
	mov	edi, ebp
	lea	ebx, DWORD PTR [esi+10]
	mov	ebp, 8
$LL3@FastAlloca:

; 212  : 	{
; 213  : #pragma warning(suppress: 6297) //warning c6297: Result of shift cast to larger size
; 214  : 		allocators[i].Init(1 << (i + MIN_ALLOC_BIT));

	mov	eax, esi
	rol	eax, 3

; 104  : 	Init(element_size);
; 105  : };
; 106  : 
; 107  : inline FastFixedAllocator::~FastFixedAllocator() // *not* thread safe
; 108  : {
; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())
; 110  : 	{
; 111  : 		delete n;
; 112  : 	};
; 113  : };
; 114  : 
; 115  : inline void FastFixedAllocator::Grow()
; 116  : {
; 117  : 	Chunk* n = new Chunk;
; 118  : 	Chunks.Push(n);
; 119  : 
; 120  : #ifdef FASTALLOC_STATS
; 121  : 	_InterlockedExchangeAdd((long *)&TotalHeapSize, sizeof(Chunk));
; 122  : #endif
; 123  : 
; 124  : 	const size_t number_elements = Chunk::size / ElementSize;
; 125  : 
; 126  : 	for (size_t i = 0; i < number_elements; ++i)
; 127  : 	{
; 128  : 		Link* link = (Link*)(n->Memory + (i * ElementSize) );
; 129  : 		link->Next = 0;
; 130  : 		FreeList.Push(link);
; 131  : 	};
; 132  : };
; 133  : 
; 134  : inline void FastFixedAllocator::Init(size_t element_size)
; 135  : {
; 136  : 	this->ElementSize = element_size < sizeof(Link) ? sizeof (Link) : element_size;

	cmp	eax, 8
	cmovb	eax, ebp

; 215  : 		allocators[i].Grow(); // let's do the first growing here so that we don't fight over allocating

	mov	ecx, edi

; 104  : 	Init(element_size);
; 105  : };
; 106  : 
; 107  : inline FastFixedAllocator::~FastFixedAllocator() // *not* thread safe
; 108  : {
; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())
; 110  : 	{
; 111  : 		delete n;
; 112  : 	};
; 113  : };
; 114  : 
; 115  : inline void FastFixedAllocator::Grow()
; 116  : {
; 117  : 	Chunk* n = new Chunk;
; 118  : 	Chunks.Push(n);
; 119  : 
; 120  : #ifdef FASTALLOC_STATS
; 121  : 	_InterlockedExchangeAdd((long *)&TotalHeapSize, sizeof(Chunk));
; 122  : #endif
; 123  : 
; 124  : 	const size_t number_elements = Chunk::size / ElementSize;
; 125  : 
; 126  : 	for (size_t i = 0; i < number_elements; ++i)
; 127  : 	{
; 128  : 		Link* link = (Link*)(n->Memory + (i * ElementSize) );
; 129  : 		link->Next = 0;
; 130  : 		FreeList.Push(link);
; 131  : 	};
; 132  : };
; 133  : 
; 134  : inline void FastFixedAllocator::Init(size_t element_size)
; 135  : {
; 136  : 	this->ElementSize = element_size < sizeof(Link) ? sizeof (Link) : element_size;

	mov	DWORD PTR [edi+16], eax

; 215  : 		allocators[i].Grow(); // let's do the first growing here so that we don't fight over allocating

	call	?Grow@FastFixedAllocator@@QAEXXZ	; FastFixedAllocator::Grow
	add	edi, 32					; 00000020H
	rol	esi, 1
	dec	ebx
	jne	SHORT $LL3@FastAlloca

; 216  : 	};
; 217  : };

	mov	eax, DWORD PTR _this$1$[esp+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	0
??0FastAllocatorGeneral@@QAE@XZ ENDP			; FastAllocatorGeneral::FastAllocatorGeneral
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_FFastFixedAllocator@@QAEXXZ
_TEXT	SEGMENT
??_FFastFixedAllocator@@QAEXXZ PROC			; FastFixedAllocator::`default constructor closure', COMDAT
; _this$ = ecx
	push	ecx
	call	??0FastFixedAllocator@@QAE@I@Z		; FastFixedAllocator::FastFixedAllocator
	ret	0
??_FFastFixedAllocator@@QAEXXZ ENDP			; FastFixedAllocator::`default constructor closure'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
;	COMDAT ??__E__general_allocator@@YAXXZ
text$yc	SEGMENT
??__E__general_allocator@@YAXXZ PROC			; `dynamic initializer for '__general_allocator'', COMDAT

; 19   : 
; 20   : FastAllocatorGeneral* FastAllocatorGeneral::Get_Allocator()
; 21   : {
; 22   : 	return __general_allocator;	
; 23   : };
; 24   : 
; 25   : // Please modify these next two functions to call a system allocator
; 26   : DECLSPEC_RESTRICT void* SystemAllocate(size_t size)
; 27   : {
; 28   : 	void* memory = malloc(size);

	push	368					; 00000170H
	call	DWORD PTR __imp__malloc
	add	esp, 4

; 29   : 	// If you hit this assert, you've run out of memory. This is bad.
; 30   : 	assert(memory);

	test	eax, eax
	jne	SHORT $LN12@dynamic
	push	30					; 0000001eH
	push	OFFSET ??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH

; 18   : static FastAllocatorGeneral* __general_allocator = new FastAllocatorGeneral();

	mov	DWORD PTR ___general_allocator, 0
	ret	0
$LN12@dynamic:
	mov	ecx, eax
	call	??0FastAllocatorGeneral@@QAE@XZ		; FastAllocatorGeneral::FastAllocatorGeneral
	mov	DWORD PTR ___general_allocator, eax
	ret	0
??__E__general_allocator@@YAXXZ ENDP			; `dynamic initializer for '__general_allocator''
text$yc	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
;	COMDAT ?Get_Allocator@FastAllocatorGeneral@@SAPAV1@XZ
_TEXT	SEGMENT
?Get_Allocator@FastAllocatorGeneral@@SAPAV1@XZ PROC	; FastAllocatorGeneral::Get_Allocator, COMDAT

; 22   : 	return __general_allocator;	

	mov	eax, DWORD PTR ___general_allocator

; 23   : };

	ret	0
?Get_Allocator@FastAllocatorGeneral@@SAPAV1@XZ ENDP	; FastAllocatorGeneral::Get_Allocator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ?Push@?$TSList@ULink@FastFixedAllocator@@@@QAEXPAULink@FastFixedAllocator@@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?Push@?$TSList@ULink@FastFixedAllocator@@@@QAEXPAULink@FastFixedAllocator@@@Z PROC ; TSList<FastFixedAllocator::Link>::Push, COMDAT
; _this$ = ecx

; 302  : 		assert(sizeof(T) >= sizeof(TSLNode));
; 303  : 		TSListBase::Push((TSLNode*) item); 

	jmp	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
?Push@?$TSList@ULink@FastFixedAllocator@@@@QAEXPAULink@FastFixedAllocator@@@Z ENDP ; TSList<FastFixedAllocator::Link>::Push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ?Push@?$TSList@UChunk@FastFixedAllocator@@@@QAEXPAUChunk@FastFixedAllocator@@@Z
_TEXT	SEGMENT
_item$ = 8						; size = 4
?Push@?$TSList@UChunk@FastFixedAllocator@@@@QAEXPAUChunk@FastFixedAllocator@@@Z PROC ; TSList<FastFixedAllocator::Chunk>::Push, COMDAT
; _this$ = ecx

; 302  : 		assert(sizeof(T) >= sizeof(TSLNode));
; 303  : 		TSListBase::Push((TSLNode*) item); 

	jmp	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
?Push@?$TSList@UChunk@FastFixedAllocator@@@@QAEXPAUChunk@FastFixedAllocator@@@Z ENDP ; TSList<FastFixedAllocator::Chunk>::Push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ?Pop@?$TSList@UChunk@FastFixedAllocator@@@@QAEPAUChunk@FastFixedAllocator@@XZ
_TEXT	SEGMENT
?Pop@?$TSList@UChunk@FastFixedAllocator@@@@QAEPAUChunk@FastFixedAllocator@@XZ PROC ; TSList<FastFixedAllocator::Chunk>::Pop, COMDAT
; _this$ = ecx

; 308  : 		return (T*) TSListBase::Pop();

	jmp	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
?Pop@?$TSList@UChunk@FastFixedAllocator@@@@QAEPAUChunk@FastFixedAllocator@@XZ ENDP ; TSList<FastFixedAllocator::Chunk>::Pop
_TEXT	ENDS
END
