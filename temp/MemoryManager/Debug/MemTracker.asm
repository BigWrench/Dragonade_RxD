; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61219.0 

	TITLE	X:\GitHub\Renegade\Dragonade_RxD\MemoryManager\MemTracker.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_1HO@PBNFMELI@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@ ; `string'
PUBLIC	??_C@_1EE@PCKHKONG@?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@ ; `string'
PUBLIC	??_C@_1CG@HEKIGBGD@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@OMNJOPJE@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@FJPHHHDI@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@HHINBFPG@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAN?$AAe?$AAx?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EC@OCKBJEMP@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAP?$AAr?$AAe?$AAv?$AAi?$AAo?$AAu?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ ; `string'
PUBLIC	??_C@_1CG@DFKNIMDF@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@KNNMACMC@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@JPJLGBEJ@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@ICFGHNLI@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DO@LKPDNKFE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_01KICIPPFI@?2?$AA@			; `string'
PUBLIC	??_C@_0N@LFFEOAII@debug?2memory?$AA@		; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_0BH@FABFNODC@debug?2memory?2leaks?4txt?$AA@ ; `string'
PUBLIC	??_C@_0CK@FBKOEIAE@Failed?5to?5write?5to?5debug?2memory?2@ ; `string'
PUBLIC	??_C@_0DC@DDHDNAPJ@address?7size?7file?7function?7line?7@ ; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown?$AA@			; `string'
PUBLIC	??_C@_03CLCAEGCJ@new?$AA@			; `string'
PUBLIC	??_C@_05LEAFLCCG@new?$FL?$FN?$AA@		; `string'
PUBLIC	??_C@_06GLDDLHNF@malloc?$AA@			; `string'
PUBLIC	??_C@_06DLAMMMII@calloc?$AA@			; `string'
PUBLIC	??_C@_07EOOHGPEI@realloc?$AA@			; `string'
PUBLIC	??_C@_0M@IPKDCNKC@unvalidated?$AA@		; `string'
PUBLIC	??_C@_0CL@FJOGLINP@0x?$CF08p?70x?$CF04IX?5?$CI?$CFIu?$CJ?7?$CF?4128s?7?$CF?412@ ; `string'
PUBLIC	??_C@_0BH@FOPENCFM@?$CFd?5Memory?5Leaks?5found?6?$AA@ ; `string'
PUBLIC	??_C@_1CO@POGMJGLI@?$AA?$CK?$AAp?$AAr?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAR?$AAE?$AAF?$AAI?$AAX?$AA_?$AAP?$AAA?$AAT?$AAT?$AAE?$AAR?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@HBEBNFEC@?$AA?$CK?$AAp?$AAo?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAO?$AAS?$AAT?$AAF?$AAI?$AAX?$AA_?$AAP?$AAA?$AAT?$AAT?$AAE?$AAR?$AAN?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@LBCBPKFK@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp?$AAe?$AA_?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@NNABAJNA@?$AAt?$AAa?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@JJIKBPKF@?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAc?$AAt?$AAu?$AAa?$AAl?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@EPMGAHAB@?$AAV?$AAa?$AAl?$AAi?$AAd?$AAa?$AAt?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CI?$AAt?$AAa?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KO@HLDIACEN@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@ ; `string'
PUBLIC	??_C@_1DI@CBDDEKGK@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp?$AAe?$AA_?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FGC@DNPNIFOO@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@ ; `string'
PUBLIC	??_C@_1NC@OEFKFEOF@?$AA?$CB?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAB?$AAr?$AAe?$AAa?$AAk?$AAO?$AAn?$AAF?$AAr?$AAe?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAe@ ; `string'
PUBLIC	__GUID_11a66efa_382e_451a_9234_1e0e12ef3085
PUBLIC	?CurrentAllocationCount@MemoryTracker@@1JA	; MemoryTracker::CurrentAllocationCount
PUBLIC	__GUID_43826d1e_e718_42ee_bc55_a1e261c37bfe
EXTRN	__imp__strncpy_s:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__strrchr:PROC
EXTRN	__imp__SHCreateDirectoryExA@12:PROC
EXTRN	__imp__SetCurrentDirectoryA@4:PROC
EXTRN	__imp__strcpy_s:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__fopen:PROC
EXTRN	_atexit:PROC
EXTRN	__imp__PathFileExistsA@4:PROC
EXTRN	__imp__sprintf:PROC
?CurrentAllocationCount@MemoryTracker@@1JA DD 01H DUP (?) ; MemoryTracker::CurrentAllocationCount
_BSS	ENDS
;	COMDAT __GUID_43826d1e_e718_42ee_bc55_a1e261c37bfe
CONST	SEGMENT
__GUID_43826d1e_e718_42ee_bc55_a1e261c37bfe DD 043826d1eH
	DW	0e718H
	DW	042eeH
	DB	0bcH
	DB	055H
	DB	0a1H
	DB	0e2H
	DB	061H
	DB	0c3H
	DB	07bH
	DB	0feH
CONST	ENDS
;	COMDAT __GUID_11a66efa_382e_451a_9234_1e0e12ef3085
CONST	SEGMENT
__GUID_11a66efa_382e_451a_9234_1e0e12ef3085 DD 011a66efaH
	DW	0382eH
	DW	0451aH
	DB	092H
	DB	034H
	DB	01eH
	DB	0eH
	DB	012H
	DB	0efH
	DB	030H
	DB	085H
CONST	ENDS
;	COMDAT ??_C@_1NC@OEFKFEOF@?$AA?$CB?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAB?$AAr?$AAe?$AAa?$AAk?$AAO?$AAn?$AAF?$AAr?$AAe?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAe@
CONST	SEGMENT
??_C@_1NC@OEFKFEOF@?$AA?$CB?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAB?$AAr?$AAe?$AAa?$AAk?$AAO?$AAn?$AAF?$AAr?$AAe?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAD?$AAe@ DB '!'
	DB	00H, '(', 00H, 't', 00H, 'a', 00H, 'g', 00H, '-', 00H, '>', 00H
	DB	'B', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'k', 00H, 'O', 00H, 'n'
	DB	00H, 'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, '_', 00H, 'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H
	DB	')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, '!', 00H, '('
	DB	00H, 't', 00H, 'a', 00H, 'g', 00H, '-', 00H, '>', 00H, 'B', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 'k', 00H, 'O', 00H, 'n', 00H, 'R'
	DB	00H, 'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 't', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'D', 00H
	DB	'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'R', 00H, 'e', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FGC@DNPNIFOO@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@
CONST	SEGMENT
??_C@_1FGC@DNPNIFOO@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@ DB '('
	DB	00H, 't', 00H, 'a', 00H, 'g', 00H, '-', 00H, '>', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'A', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'_', 00H, 'N', 00H, 'e', 00H, 'w', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '_', 00H, 'D', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 't'
	DB	00H, 'e', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H
	DB	'(', 00H, 't', 00H, 'a', 00H, 'g', 00H, '-', 00H, '>', 00H, 'A'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'A', 00H, 'l', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, '_', 00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, 'N', 00H, 'e', 00H, 'w', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '_', 00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 'D', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 't', 00H
	DB	'e', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, '('
	DB	00H, 't', 00H, 'a', 00H, 'g', 00H, '-', 00H, '>', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'A', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'_', 00H, 'M', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'D'
	DB	00H, 'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'F', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, 't', 00H, 'a', 00H, 'g', 00H, '-', 00H, '>'
	DB	00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, '_', 00H, 'C', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 't'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'D', 00H, 'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H
	DB	'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H, ')', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, '(', 00H, 't', 00H, 'a', 00H, 'g', 00H
	DB	'-', 00H, '>', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'R', 00H, 'e', 00H, 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, '_', 00H, 'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H
	DB	')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, '(', 00H, 't'
	DB	00H, 'a', 00H, 'g', 00H, '-', 00H, '>', 00H, 'A', 00H, 'l', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H
	DB	'M', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, 't', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'D', 00H, 'e'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'R', 00H, 'e', 00H, 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, ')', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, '(', 00H, 't', 00H, 'a', 00H, 'g'
	DB	00H, '-', 00H, '>', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H
	DB	'c', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H
	DB	'e', 00H, '_', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, 't', 00H, 'a', 00H, 'g', 00H, '-', 00H, '>'
	DB	00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, '_', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'l', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'_', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H
	DB	'(', 00H, 't', 00H, 'a', 00H, 'g', 00H, '-', 00H, '>', 00H, 'A'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'A', 00H, 'l', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, '_', 00H, 'U', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ')'
	DB	00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, '(', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'D', 00H, 'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H
	DB	'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'U'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@CBDDEKGK@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp?$AAe?$AA_?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@CBDDEKGK@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp?$AAe?$AA_?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@ DB 't'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'D', 00H, 'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H
	DB	'U', 00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H, 'w', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1KO@HLDIACEN@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@
CONST	SEGMENT
??_C@_1KO@HLDIACEN@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@ DB '('
	DB	00H, 't', 00H, 'a', 00H, 'g', 00H, '-', 00H, '>', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'A', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'_', 00H, 'N', 00H, 'e', 00H, 'w', 00H, ')', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, '(', 00H, 't', 00H, 'a', 00H, 'g', 00H
	DB	'-', 00H, '>', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'V', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 'N', 00H, 'e', 00H, 'w', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@EPMGAHAB@?$AAV?$AAa?$AAl?$AAi?$AAd?$AAa?$AAt?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CI?$AAt?$AAa?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@EPMGAHAB@?$AAV?$AAa?$AAl?$AAi?$AAd?$AAa?$AAt?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CI?$AAt?$AAa?$AAg?$AA?$CJ?$AA?$AA@ DB 'V'
	DB	00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'U', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, '(', 00H, 't', 00H, 'a', 00H, 'g', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@JJIKBPKF@?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAc?$AAt?$AAu?$AAa?$AAl?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@JJIKBPKF@?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAc?$AAt?$AAu?$AAa?$AAl?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'g', 00H, '-', 00H, '>', 00H, 'A', 00H, 'c', 00H
	DB	't', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'A', 00H, 'd', 00H, 'd'
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 's', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@NNABAJNA@?$AAt?$AAa?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@NNABAJNA@?$AAt?$AAa?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'g', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@LBCBPKFK@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp?$AAe?$AA_?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@LBCBPKFK@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp?$AAe?$AA_?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@ DB 't'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'T'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, '_', 00H, 'U', 00H, 'n', 00H
	DB	'k', 00H, 'n', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@HBEBNFEC@?$AA?$CK?$AAp?$AAo?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAO?$AAS?$AAT?$AAF?$AAI?$AAX?$AA_?$AAP?$AAA?$AAT?$AAT?$AAE?$AAR?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@HBEBNFEC@?$AA?$CK?$AAp?$AAo?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAO?$AAS?$AAT?$AAF?$AAI?$AAX?$AA_?$AAP?$AAA?$AAT?$AAT?$AAE?$AAR?$AAN?$AA?$AA@ DB '*'
	DB	00H, 'p', 00H, 'o', 00H, 's', 00H, 't', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'P', 00H, 'O', 00H, 'S', 00H, 'T', 00H, 'F'
	DB	00H, 'I', 00H, 'X', 00H, '_', 00H, 'P', 00H, 'A', 00H, 'T', 00H
	DB	'T', 00H, 'E', 00H, 'R', 00H, 'N', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@POGMJGLI@?$AA?$CK?$AAp?$AAr?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAR?$AAE?$AAF?$AAI?$AAX?$AA_?$AAP?$AAA?$AAT?$AAT?$AAE?$AAR?$AAN?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@POGMJGLI@?$AA?$CK?$AAp?$AAr?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAR?$AAE?$AAF?$AAI?$AAX?$AA_?$AAP?$AAA?$AAT?$AAT?$AAE?$AAR?$AAN?$AA?$AA@ DB '*'
	DB	00H, 'p', 00H, 'r', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'P', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'I', 00H, 'X'
	DB	00H, '_', 00H, 'P', 00H, 'A', 00H, 'T', 00H, 'T', 00H, 'E', 00H
	DB	'R', 00H, 'N', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FOPENCFM@?$CFd?5Memory?5Leaks?5found?6?$AA@
CONST	SEGMENT
??_C@_0BH@FOPENCFM@?$CFd?5Memory?5Leaks?5found?6?$AA@ DB '%d Memory Leaks'
	DB	' found', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FJOGLINP@0x?$CF08p?70x?$CF04IX?5?$CI?$CFIu?$CJ?7?$CF?4128s?7?$CF?412@
CONST	SEGMENT
??_C@_0CL@FJOGLINP@0x?$CF08p?70x?$CF04IX?5?$CI?$CFIu?$CJ?7?$CF?4128s?7?$CF?412@ DB '0'
	DB	'x%08p', 09H, '0x%04IX (%Iu)', 09H, '%.128s', 09H, '%.128s', 09H
	DB	'%d', 09H, '%s', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IPKDCNKC@unvalidated?$AA@
CONST	SEGMENT
??_C@_0M@IPKDCNKC@unvalidated?$AA@ DB 'unvalidated', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOOHGPEI@realloc?$AA@
CONST	SEGMENT
??_C@_07EOOHGPEI@realloc?$AA@ DB 'realloc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLAMMMII@calloc?$AA@
CONST	SEGMENT
??_C@_06DLAMMMII@calloc?$AA@ DB 'calloc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GLDDLHNF@malloc?$AA@
CONST	SEGMENT
??_C@_06GLDDLHNF@malloc?$AA@ DB 'malloc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LEAFLCCG@new?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_05LEAFLCCG@new?$FL?$FN?$AA@ DB 'new[]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03CLCAEGCJ@new?$AA@
CONST	SEGMENT
??_C@_03CLCAEGCJ@new?$AA@ DB 'new', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown?$AA@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown?$AA@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DDHDNAPJ@address?7size?7file?7function?7line?7@
CONST	SEGMENT
??_C@_0DC@DDHDNAPJ@address?7size?7file?7function?7line?7@ DB 'address', 09H
	DB	'size', 09H, 'file', 09H, 'function', 09H, 'line', 09H, 'alloc'
	DB	'ation type', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FBKOEIAE@Failed?5to?5write?5to?5debug?2memory?2@
CONST	SEGMENT
??_C@_0CK@FBKOEIAE@Failed?5to?5write?5to?5debug?2memory?2@ DB 'Failed to '
	DB	'write to debug\memory\leaks.txt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FABFNODC@debug?2memory?2leaks?4txt?$AA@
CONST	SEGMENT
??_C@_0BH@FABFNODC@debug?2memory?2leaks?4txt?$AA@ DB 'debug\memory\leaks.'
	DB	'txt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LFFEOAII@debug?2memory?$AA@
CONST	SEGMENT
??_C@_0N@LFFEOAII@debug?2memory?$AA@ DB 'debug\memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2?$AA@
CONST	SEGMENT
??_C@_01KICIPPFI@?2?$AA@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@LKPDNKFE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@LKPDNKFE@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CJ?$AA?$AA@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f'
	DB	00H, '(', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'U', 00H, 'n'
	DB	00H, 'i', 00H, 't', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@ DB 'M'
	DB	00H, 'e', 00H, 'm', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'k', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@ICFGHNLI@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@ICFGHNLI@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'h', 00H, 'i', 00H, 's', 00H, '-', 00H, '>', 00H, 'L', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JPJLGBEJ@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JPJLGBEJ@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?$AA@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '-', 00H, '>', 00H, 'L', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 't', 00H, 'h', 00H, 'i', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@KNNMACMC@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@KNNMACMC@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'h', 00H, 'i', 00H, 's', 00H, '-', 00H, '>', 00H, 'T', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@DFKNIMDF@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@DFKNIMDF@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'h', 00H, 'i', 00H, 's', 00H, '-', 00H, '>', 00H, 'H', 00H
	DB	'e', 00H, 'a', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@OCKBJEMP@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAP?$AAr?$AAe?$AAv?$AAi?$AAo?$AAu?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
CONST	SEGMENT
??_C@_1EC@OCKBJEMP@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAP?$AAr?$AAe?$AAv?$AAi?$AAo?$AAu?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 't', 00H, 'o', 00H
	DB	'_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 'e', 00H, 'r', 00H, 't'
	DB	00H, '-', 00H, '>', 00H, 'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'o', 00H, 'u', 00H, 's', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@HHINBFPG@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAN?$AAe?$AAx?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@HHINBFPG@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAN?$AAe?$AAx?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 't', 00H, 'o', 00H
	DB	'_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 'e', 00H, 'r', 00H, 't'
	DB	00H, '-', 00H, '>', 00H, 'N', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L'
	DB	00H, 'L', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@FJPHHHDI@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@FJPHHHDI@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'n'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 't', 00H, 'o', 00H
	DB	'_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 'e', 00H, 'r', 00H, 't'
	DB	00H, '-', 00H, '>', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L'
	DB	00H, 'L', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@OMNJOPJE@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@OMNJOPJE@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'h', 00H, 'i', 00H, 's', 00H, '-', 00H, '>', 00H, 'T', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@HEKIGBGD@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@HEKIGBGD@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'h', 00H, 'i', 00H, 's', 00H, '-', 00H, '>', 00H, 'H', 00H
	DB	'e', 00H, 'a', 00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
CONST	SEGMENT
??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@ DB 'x'
	DB	00H, ':', 00H, '\', 00H, 'g', 00H, 'i', 00H, 't', 00H, 'h', 00H
	DB	'u', 00H, 'b', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'e'
	DB	00H, 'g', 00H, 'a', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'd', 00H
	DB	'r', 00H, 'a', 00H, 'g', 00H, 'o', 00H, 'n', 00H, 'a', 00H, 'd'
	DB	00H, 'e', 00H, '_', 00H, 'r', 00H, 'x', 00H, 'd', 00H, '\', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H
	DB	'\', 00H, 'D', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@PCKHKONG@?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1EE@PCKHKONG@?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ DB '('
	DB	00H, 'i', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, ' ', 00H
	DB	'&', 00H, ' ', 00H, '0', 00H, 'x', 00H, 'F', 00H, 'F', 00H, 'F'
	DB	00H, 'F', 00H, 'F', 00H, 'F', 00H, 'F', 00H, 'F', 00H, '0', 00H
	DB	'0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '0'
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1HO@PBNFMELI@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
CONST	SEGMENT
??_C@_1HO@PBNFMELI@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@ DB 'x'
	DB	00H, ':', 00H, '\', 00H, 'g', 00H, 'i', 00H, 't', 00H, 'h', 00H
	DB	'u', 00H, 'b', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'e'
	DB	00H, 'g', 00H, 'a', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'd', 00H
	DB	'r', 00H, 'a', 00H, 'g', 00H, 'o', 00H, 'n', 00H, 'a', 00H, 'd'
	DB	00H, 'e', 00H, '_', 00H, 'r', 00H, 'x', 00H, 'd', 00H, '\', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'r', 00H
	DB	'\', 00H, 'F', 00H, 'a', 00H, 's', 00H, 't', 00H, 'A', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, '.', 00H, 'h', 00H, 00H, 00H	; `string'
PUBLIC	??$UNUSED_VARIABLE@PBD@@YAXABQBD@Z		; UNUSED_VARIABLE<char const *>
PUBLIC	??$strncpy_s@$0IA@@@YAHAAY0IA@DPBDI@Z		; strncpy_s<128>
PUBLIC	??$UNUSED_VARIABLE@I@@YAXABI@Z			; UNUSED_VARIABLE<unsigned int>
PUBLIC	?PopHead@?$DList@VAllocationUnit@@@@QAEPAVAllocationUnit@@XZ ; DList<AllocationUnit>::PopHead
PUBLIC	?Free@?$FastObjectAllocator@VAllocationUnit@@@@QAEXPAX@Z ; FastObjectAllocator<AllocationUnit>::Free
PUBLIC	?Allocate@?$FastObjectAllocator@VAllocationUnit@@@@QAEPAXXZ ; FastObjectAllocator<AllocationUnit>::Allocate
PUBLIC	??1?$FastObjectAllocator@VAllocationUnit@@@@QAE@XZ ; FastObjectAllocator<AllocationUnit>::~FastObjectAllocator<AllocationUnit>
PUBLIC	??0?$FastObjectAllocator@VAllocationUnit@@@@QAE@XZ ; FastObjectAllocator<AllocationUnit>::FastObjectAllocator<AllocationUnit>
PUBLIC	?Pop@?$TSList@ULink@FastFixedAllocator@@@@QAEPAULink@FastFixedAllocator@@XZ ; TSList<FastFixedAllocator::Link>::Pop
PUBLIC	?ValidateAllocationUnit@MemoryTracker@@KA_NPAVAllocationUnit@@@Z ; MemoryTracker::ValidateAllocationUnit
PUBLIC	?WipeMemoryWithPattern@MemoryTracker@@KAXPAVAllocationUnit@@HI@Z ; MemoryTracker::WipeMemoryWithPattern
PUBLIC	?FindAllocationUnit@MemoryTracker@@KAPAVAllocationUnit@@PAX@Z ; MemoryTracker::FindAllocationUnit
PUBLIC	?GetMemoryTrackingCost@MemoryTracker@@KA?BIXZ	; MemoryTracker::GetMemoryTrackingCost
PUBLIC	??1AllocationUnit@@QAE@XZ			; AllocationUnit::~AllocationUnit
PUBLIC	??_GAllocationUnit@@QAEPAXI@Z			; AllocationUnit::`scalar deleting destructor'
PUBLIC	??1MemoryTracker@@QAE@XZ			; MemoryTracker::~MemoryTracker
PUBLIC	??3AllocationUnit@@SAXPAX@Z			; AllocationUnit::operator delete
PUBLIC	??2AllocationUnit@@SAPAXI@Z			; AllocationUnit::operator new
PUBLIC	??1?$DList@VAllocationUnit@@@@QAE@XZ		; DList<AllocationUnit>::~DList<AllocationUnit>
PUBLIC	??0?$DList@VAllocationUnit@@@@QAE@XZ		; DList<AllocationUnit>::DList<AllocationUnit>
PUBLIC	??1Lock@FastCriticalSection@@QAE@XZ		; FastCriticalSection::Lock::~Lock
PUBLIC	??0Lock@FastCriticalSection@@QAE@AAV1@@Z	; FastCriticalSection::Lock::Lock
PUBLIC	?Leave@FastCriticalSection@@QAEXXZ		; FastCriticalSection::Leave
PUBLIC	?Enter@FastCriticalSection@@QAEXXZ		; FastCriticalSection::Enter
PUBLIC	??0FastCriticalSection@@QAE@XZ			; FastCriticalSection::FastCriticalSection
PUBLIC	?ClearThreadLocalInformation@MemoryTracker@@KAXXZ ; MemoryTracker::ClearThreadLocalInformation
PUBLIC	?CalculatePostfixSentinelStartAddress@MemoryTracker@@KAPAXPAVAllocationUnit@@@Z ; MemoryTracker::CalculatePostfixSentinelStartAddress
PUBLIC	?CalculatePrefixSentinelStartAddress@MemoryTracker@@KAPAXPAVAllocationUnit@@@Z ; MemoryTracker::CalculatePrefixSentinelStartAddress
PUBLIC	?CalculateReportedAddress@MemoryTracker@@KAPAXPAX@Z ; MemoryTracker::CalculateReportedAddress
PUBLIC	?CalculateActualAddress@MemoryTracker@@KAPAXPAX@Z ; MemoryTracker::CalculateActualAddress
PUBLIC	??1?$DLNode@VAllocationUnit@@@@QAE@XZ		; DLNode<AllocationUnit>::~DLNode<AllocationUnit>
PUBLIC	??0?$DLNode@VAllocationUnit@@@@QAE@XZ		; DLNode<AllocationUnit>::DLNode<AllocationUnit>
PUBLIC	??0AllocationUnit@@QAE@XZ			; AllocationUnit::AllocationUnit
PUBLIC	?Remove@DLNodeBase@@QAEXXZ			; DLNodeBase::Remove
PUBLIC	??1DLNodeBase@@QAE@XZ				; DLNodeBase::~DLNodeBase
PUBLIC	??0DLNodeBase@@QAE@XZ				; DLNodeBase::DLNodeBase
PUBLIC	?PopHead@DListBase@@QAEPAVDLNodeBase@@XZ	; DListBase::PopHead
PUBLIC	?PushTail@DListBase@@QAEXPAVDLNodeBase@@@Z	; DListBase::PushTail
PUBLIC	?Remove@DListBase@@QAEPAVDLNodeBase@@PAV2@@Z	; DListBase::Remove
PUBLIC	?InsertAfter@DListBase@@QAEXPAVDLNodeBase@@0@Z	; DListBase::InsertAfter
PUBLIC	??1DListBase@@QAE@XZ				; DListBase::~DListBase
PUBLIC	??0DListBase@@QAE@XZ				; DListBase::DListBase
PUBLIC	?Free@FastAllocatorGeneral@@QAEXPAX@Z		; FastAllocatorGeneral::Free
PUBLIC	?Allocate@FastAllocatorGeneral@@QAEPAXI@Z	; FastAllocatorGeneral::Allocate
PUBLIC	?GetAllocatorIndex@FastAllocatorGeneral@@IBEKI@Z ; FastAllocatorGeneral::GetAllocatorIndex
PUBLIC	?Free@FastFixedAllocator@@QAEXPAX@Z		; FastFixedAllocator::Free
PUBLIC	?Allocate@FastFixedAllocator@@QAEPAXXZ		; FastFixedAllocator::Allocate
PUBLIC	?GetSize@FastFixedAllocator@@QBEIXZ		; FastFixedAllocator::GetSize
PUBLIC	?strrchr@@YAPADPADH@Z				; strrchr
PUBLIC	?GetAllocationSize@MemoryTracker@@SAIPAX@Z	; MemoryTracker::GetAllocationSize
PUBLIC	?Free@MemoryTracker@@SAXPAXW4DeallocType@@PBD2H@Z ; MemoryTracker::Free
PUBLIC	?Reallocate@MemoryTracker@@SAPAXPAXIPBD1H@Z	; MemoryTracker::Reallocate
PUBLIC	?Allocate@MemoryTracker@@SAPAXIW4AllocType@@PBD1H@Z ; MemoryTracker::Allocate
PUBLIC	?PopAllocationTag@MemoryTracker@@SAXXZ		; MemoryTracker::PopAllocationTag
PUBLIC	?PushAllocationTag@MemoryTracker@@SAXPBD@Z	; MemoryTracker::PushAllocationTag
PUBLIC	?SetThreadLocalInformation@MemoryTracker@@SAXPBD0H@Z ; MemoryTracker::SetThreadLocalInformation
PUBLIC	?GetThreadLocalInformation@MemoryTracker@@SAPAVMemoryTrackerThreadLocalInformation@@XZ ; MemoryTracker::GetThreadLocalInformation
_MemoryTrackerCS DD 01H DUP (?)
	ALIGN	8

_Tags	DQ	01H DUP (?)
_TagAllocator DB 020H DUP (?)
_MemoryTrackerInstance DB 01H DUP (?)
_BSS	ENDS
_MemoryTrackerCS$initializer$ DD FLAT:??__EMemoryTrackerCS@@YAXXZ
_TagAllocator$initializer$ DD FLAT:??__ETagAllocator@@YAXXZ
_Tags$initializer$ DD FLAT:??__ETags@@YAXXZ
_MemoryTrackerInstance$initializer$ DD FLAT:??__EMemoryTrackerInstance@@YAXXZ
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?GetThreadLocalInformation@MemoryTracker@@SAPAVMemoryTrackerThreadLocalInformation@@XZ
_TEXT	SEGMENT
?GetThreadLocalInformation@MemoryTracker@@SAPAVMemoryTrackerThreadLocalInformation@@XZ PROC ; MemoryTracker::GetThreadLocalInformation, COMDAT

; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	push	DWORD PTR ?TLSIndex@@3KA		; TLSIndex
	call	DWORD PTR __imp__TlsGetValue@4

; 220  : 	return (MemoryTrackerThreadLocalInformation*)tls_mem;
; 221  : };

	ret	0
?GetThreadLocalInformation@MemoryTracker@@SAPAVMemoryTrackerThreadLocalInformation@@XZ ENDP ; MemoryTracker::GetThreadLocalInformation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?SetThreadLocalInformation@MemoryTracker@@SAXPBD0H@Z
_TEXT	SEGMENT
_source_line$ = 8					; size = 4
?SetThreadLocalInformation@MemoryTracker@@SAXPBD0H@Z PROC ; MemoryTracker::SetThreadLocalInformation, COMDAT
; _source_file$ = ecx
; _source_function$ = edx

; 224  : {

	push	ebx
	push	ebp
	push	esi

; 135  : 	return source_file;
; 136  : }
; 137  : 
; 138  : const size_t MemoryTracker::GetMemoryTrackingCost()
; 139  : {
; 140  : 	// pointer size + sentinel size
; 141  : 	return sizeof(AllocationUnit*) + (SENTINEL_SIZE * sizeof(int32) * 2);
; 142  : };
; 143  : 
; 144  : AllocationUnit* MemoryTracker::FindAllocationUnit(void* memory)
; 145  : {
; 146  : 	void* actual = CalculateActualAddress(memory);
; 147  : 	int32* sentinel_start =  (int32*)((char*) actual + sizeof(AllocationUnit*));
; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation
; 149  : 	return *(AllocationUnit**) actual;
; 150  : };
; 151  : 
; 152  : void MemoryTracker::WipeMemoryWithPattern(AllocationUnit* unit, int32 pattern, size_t bias)
; 153  : {
; 154  : 
; 155  : #ifdef ALWAYS_WIPE_MEMORY
; 156  : 
; 157  : 	// fill the bulk of the allocation
; 158  : 	int32* iptr = (int32*)((char*)unit->ReportedAddress + bias);
; 159  : 	size_t length = unit->ReportedSize - bias;
; 160  : 	for (size_t i = 0; i < (length / 4); ++i)
; 161  : 	{
; 162  : 		*++iptr = pattern;
; 163  : 	};
; 164  : 
; 165  : 	// fill the remainder	
; 166  : 	char* cptr = (char*)iptr;
; 167  : 	for (size_t i = 0, shiftcount = 0; i < (length & 0x3); ++i, shiftcount += 8)
; 168  : 	{
; 169  : 		*++cptr = char(pattern & (0xFF << shiftcount) >> shiftcount);
; 170  : 	}
; 171  : #else
; 172  : 	UNUSED_VARIABLE(pattern);
; 173  : 	UNUSED_VARIABLE(bias);
; 174  : #endif
; 175  : 
; 176  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 177  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 178  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 179  : 	{
; 180  : 		*pre = PREFIX_PATTERN;
; 181  : 		*post = POSTFIX_PATTERN;
; 182  : 	};
; 183  : };
; 184  : 
; 185  : 
; 186  : bool MemoryTracker::ValidateAllocationUnit(AllocationUnit* unit)
; 187  : {
; 188  : 	// make sure the sentinels are untouched
; 189  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 190  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 191  : 	bool error_flag = false;
; 192  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 193  : 	{
; 194  : 		if (*pre != PREFIX_PATTERN)
; 195  : 		{
; 196  : 			// log this event maybe?
; 197  : 			error_flag = true;
; 198  : 		}
; 199  : 
; 200  : 		if (*post != POSTFIX_PATTERN) 
; 201  : 		{
; 202  : 			// this one too?
; 203  : 			error_flag = true;
; 204  : 		}
; 205  : 		
; 206  : 		// If you hit this assert, the sentinel before the allocation has been damaged 
; 207  : 		assert(*pre == PREFIX_PATTERN);
; 208  : 
; 209  : 		// If you hit this assert, the sentinel after the allocation has been damaged
; 210  : 		assert(*post == POSTFIX_PATTERN);
; 211  : 	};
; 212  : 	
; 213  : 	return !error_flag;
; 214  : };
; 215  : 
; 216  : extern DWORD TLSIndex; // HACK: Defined in dllmain_debug
; 217  : MemoryTrackerThreadLocalInformation* MemoryTracker::GetThreadLocalInformation()
; 218  : {
; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	push	DWORD PTR ?TLSIndex@@3KA		; TLSIndex

; 224  : {

	mov	ebp, edx
	mov	esi, ecx

; 135  : 	return source_file;
; 136  : }
; 137  : 
; 138  : const size_t MemoryTracker::GetMemoryTrackingCost()
; 139  : {
; 140  : 	// pointer size + sentinel size
; 141  : 	return sizeof(AllocationUnit*) + (SENTINEL_SIZE * sizeof(int32) * 2);
; 142  : };
; 143  : 
; 144  : AllocationUnit* MemoryTracker::FindAllocationUnit(void* memory)
; 145  : {
; 146  : 	void* actual = CalculateActualAddress(memory);
; 147  : 	int32* sentinel_start =  (int32*)((char*) actual + sizeof(AllocationUnit*));
; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation
; 149  : 	return *(AllocationUnit**) actual;
; 150  : };
; 151  : 
; 152  : void MemoryTracker::WipeMemoryWithPattern(AllocationUnit* unit, int32 pattern, size_t bias)
; 153  : {
; 154  : 
; 155  : #ifdef ALWAYS_WIPE_MEMORY
; 156  : 
; 157  : 	// fill the bulk of the allocation
; 158  : 	int32* iptr = (int32*)((char*)unit->ReportedAddress + bias);
; 159  : 	size_t length = unit->ReportedSize - bias;
; 160  : 	for (size_t i = 0; i < (length / 4); ++i)
; 161  : 	{
; 162  : 		*++iptr = pattern;
; 163  : 	};
; 164  : 
; 165  : 	// fill the remainder	
; 166  : 	char* cptr = (char*)iptr;
; 167  : 	for (size_t i = 0, shiftcount = 0; i < (length & 0x3); ++i, shiftcount += 8)
; 168  : 	{
; 169  : 		*++cptr = char(pattern & (0xFF << shiftcount) >> shiftcount);
; 170  : 	}
; 171  : #else
; 172  : 	UNUSED_VARIABLE(pattern);
; 173  : 	UNUSED_VARIABLE(bias);
; 174  : #endif
; 175  : 
; 176  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 177  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 178  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 179  : 	{
; 180  : 		*pre = PREFIX_PATTERN;
; 181  : 		*post = POSTFIX_PATTERN;
; 182  : 	};
; 183  : };
; 184  : 
; 185  : 
; 186  : bool MemoryTracker::ValidateAllocationUnit(AllocationUnit* unit)
; 187  : {
; 188  : 	// make sure the sentinels are untouched
; 189  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 190  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 191  : 	bool error_flag = false;
; 192  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 193  : 	{
; 194  : 		if (*pre != PREFIX_PATTERN)
; 195  : 		{
; 196  : 			// log this event maybe?
; 197  : 			error_flag = true;
; 198  : 		}
; 199  : 
; 200  : 		if (*post != POSTFIX_PATTERN) 
; 201  : 		{
; 202  : 			// this one too?
; 203  : 			error_flag = true;
; 204  : 		}
; 205  : 		
; 206  : 		// If you hit this assert, the sentinel before the allocation has been damaged 
; 207  : 		assert(*pre == PREFIX_PATTERN);
; 208  : 
; 209  : 		// If you hit this assert, the sentinel after the allocation has been damaged
; 210  : 		assert(*post == POSTFIX_PATTERN);
; 211  : 	};
; 212  : 	
; 213  : 	return !error_flag;
; 214  : };
; 215  : 
; 216  : extern DWORD TLSIndex; // HACK: Defined in dllmain_debug
; 217  : MemoryTrackerThreadLocalInformation* MemoryTracker::GetThreadLocalInformation()
; 218  : {
; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	call	DWORD PTR __imp__TlsGetValue@4

; 225  : 	MemoryTrackerThreadLocalInformation* info = GetThreadLocalInformation();

	mov	ebx, eax

; 226  : 	strncpy_s(info->CurrentSourceFile, source_file ? FilePathStripper(source_file) : "(Unknown File)", _TRUNCATE);

	test	esi, esi
	je	SHORT $LN3@SetThreadL

; 131  : 	const char* ptr = strrchr(source_file, '\\');

	push	92					; 0000005cH
	push	esi
	call	DWORD PTR __imp__strrchr
	add	esp, 8

; 132  : 	if (ptr) return ptr + 1;

	test	eax, eax
	jne	SHORT $LN15@SetThreadL

; 133  : 	ptr = strrchr(source_file, '/');

	push	47					; 0000002fH
	push	esi
	call	DWORD PTR __imp__strrchr
	add	esp, 8

; 134  : 	if (ptr) return ptr + 1;

	test	eax, eax
	je	SHORT $LN4@SetThreadL
$LN15@SetThreadL:
	lea	esi, DWORD PTR [eax+1]
	jmp	SHORT $LN4@SetThreadL
$LN3@SetThreadL:

; 226  : 	strncpy_s(info->CurrentSourceFile, source_file ? FilePathStripper(source_file) : "(Unknown File)", _TRUNCATE);

	mov	esi, OFFSET ??_C@_0P@OLMEFAAF@?$CIUnknown?5File?$CJ?$AA@
$LN4@SetThreadL:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	-1
	push	esi
	mov	esi, DWORD PTR __imp__strncpy_s
	push	128					; 00000080H
	push	ebx
	call	esi
	push	-1
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 227  : 	strncpy_s(info->CurrentSourceFunction, source_function ? source_function : "(Unknown Function)", _TRUNCATE);

	mov	eax, OFFSET ??_C@_0BD@OJFFOEJL@?$CIUnknown?5Function?$CJ?$AA@
	test	ebp, ebp
	cmovne	eax, ebp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	eax
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 227  : 	strncpy_s(info->CurrentSourceFunction, source_function ? source_function : "(Unknown Function)", _TRUNCATE);

	lea	eax, DWORD PTR [ebx+128]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	128					; 00000080H
	push	eax
	call	esi
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 228  : 	info->CurrentSourceLine = source_line;

	mov	eax, DWORD PTR _source_line$[esp+40]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	add	esp, 32					; 00000020H
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 228  : 	info->CurrentSourceLine = source_line;

	mov	DWORD PTR [ebx+256], eax
	pop	esi
	pop	ebp
	pop	ebx

; 229  : };

	ret	0
?SetThreadLocalInformation@MemoryTracker@@SAXPBD0H@Z ENDP ; MemoryTracker::SetThreadLocalInformation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?PushAllocationTag@MemoryTracker@@SAXPBD@Z
_TEXT	SEGMENT
?PushAllocationTag@MemoryTracker@@SAXPBD@Z PROC		; MemoryTracker::PushAllocationTag, COMDAT
; _tag$ = ecx

; 232  : {

	push	esi

; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	push	DWORD PTR ?TLSIndex@@3KA		; TLSIndex

; 232  : {

	mov	esi, ecx

; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	call	DWORD PTR __imp__TlsGetValue@4

; 233  : 	MemoryTrackerThreadLocalInformation* info = GetThreadLocalInformation();
; 234  : 	strcpy_s(info->AllocationTagStack[++info->CurrentAllocationTag], sizeof(info->AllocationTagStack[0]), tag);

	inc	DWORD PTR [eax+1284]
	mov	edx, DWORD PTR [eax+1284]
	push	esi
	shl	edx, 5
	add	eax, 260				; 00000104H
	add	eax, edx
	push	32					; 00000020H
	push	eax
	call	DWORD PTR __imp__strcpy_s
	add	esp, 12					; 0000000cH
	pop	esi

; 235  : };

	ret	0
?PushAllocationTag@MemoryTracker@@SAXPBD@Z ENDP		; MemoryTracker::PushAllocationTag
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?PopAllocationTag@MemoryTracker@@SAXXZ
_TEXT	SEGMENT
?PopAllocationTag@MemoryTracker@@SAXXZ PROC		; MemoryTracker::PopAllocationTag, COMDAT

; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	push	DWORD PTR ?TLSIndex@@3KA		; TLSIndex
	call	DWORD PTR __imp__TlsGetValue@4

; 239  : 	MemoryTrackerThreadLocalInformation* info = GetThreadLocalInformation();
; 240  : 	--info->CurrentAllocationTag;

	dec	DWORD PTR [eax+1284]

; 241  : };

	ret	0
?PopAllocationTag@MemoryTracker@@SAXXZ ENDP		; MemoryTracker::PopAllocationTag
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?Allocate@MemoryTracker@@SAPAXIW4AllocType@@PBD1H@Z
_TEXT	SEGMENT
_source_file$ = 8					; size = 4
_source_function$ = 12					; size = 4
_source_line$ = 16					; size = 4
?Allocate@MemoryTracker@@SAPAXIW4AllocType@@PBD1H@Z PROC ; MemoryTracker::Allocate, COMDAT
; _size$ = ecx
; _type$ = edx

; 244  : {

	push	ebx
	push	ebp
	push	esi

; 245  : 	// If you hit this assert, then this allocation call was made from a source that isn't setup to use our
; 246  : 	// memory tracking system. Use the callstack to locate the source and include our memory tracker header.
; 247  : 	assert(type != AllocType_Unknown);

	mov	esi, DWORD PTR __imp___wassert
	mov	ebp, edx
	push	edi
	mov	ebx, ecx
	test	ebp, ebp
	jne	SHORT $LN6@Allocate
	push	247					; 000000f7H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1DE@LBCBPKFK@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp?$AAe?$AA_?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@
	call	esi
	add	esp, 12					; 0000000cH
$LN6@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 339  : 		return allocator.Allocate();

	mov	ecx, OFFSET _TagAllocator
	call	?Allocate@FastFixedAllocator@@QAEPAXXZ	; FastFixedAllocator::Allocate
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 249  : 	AllocationUnit* tag = new AllocationUnit();

	test	eax, eax
	je	SHORT $LN7@Allocate
	mov	ecx, eax
	call	??0AllocationUnit@@QAE@XZ		; AllocationUnit::AllocationUnit
	mov	edi, eax

; 250  : 
; 251  : 	// If you've hit this assert, then you've run out of memory for the allocation tag, which is really really bad.
; 252  : 	assert(tag != NULL);

	test	edi, edi
	jne	SHORT $LN9@Allocate
	jmp	SHORT $LN68@Allocate
$LN7@Allocate:

; 249  : 	AllocationUnit* tag = new AllocationUnit();

	xor	edi, edi
$LN68@Allocate:

; 250  : 
; 251  : 	// If you've hit this assert, then you've run out of memory for the allocation tag, which is really really bad.
; 252  : 	assert(tag != NULL);

	push	252					; 000000fcH
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1BI@NNABAJNA@?$AAt?$AAa?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	esi
	add	esp, 12					; 0000000cH
$LN9@Allocate:

; 253  : 
; 254  : 	tag->ActualSize = GetMemoryTrackingCost() + size;
; 255  : 	tag->ActualAddress = FastAllocatorGeneral::Get_Allocator()->Allocate(tag->ActualSize);

	mov	ecx, DWORD PTR ___general_allocator
	lea	eax, DWORD PTR [ebx+68]
	push	eax
	mov	DWORD PTR [edi+16], eax
	call	?Allocate@FastAllocatorGeneral@@QAEPAXI@Z ; FastAllocatorGeneral::Allocate
	mov	DWORD PTR [edi+12], eax

; 256  : 	// If you've hit this assert, then you've run out of memory
; 257  : 	assert(tag->ActualAddress != NULL);

	test	eax, eax
	jne	SHORT $LN10@Allocate
	push	257					; 00000101H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1DG@JJIKBPKF@?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAc?$AAt?$AAu?$AAa?$AAl?$AAA?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	esi
	add	esp, 12					; 0000000cH
$LN10@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h

; 132  : 		return (char*)actual_address + sizeof(AllocationUnit*) + (SENTINEL_SIZE * sizeof(int32));

	mov	eax, DWORD PTR [edi+12]
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 263  : 	if (source_file) strncpy_s(tag->SourceFile, FilePathStripper(source_file), _TRUNCATE);

	mov	esi, DWORD PTR _source_file$[esp+12]
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h

; 132  : 		return (char*)actual_address + sizeof(AllocationUnit*) + (SENTINEL_SIZE * sizeof(int32));

	add	eax, 36					; 00000024H
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 259  : 	tag->ReportedSize = size;

	mov	DWORD PTR [edi+24], ebx

; 263  : 	if (source_file) strncpy_s(tag->SourceFile, FilePathStripper(source_file), _TRUNCATE);

	mov	ebx, DWORD PTR __imp__strncpy_s
	mov	DWORD PTR [edi+20], eax
	mov	DWORD PTR [edi+288], ebp
	test	esi, esi
	je	SHORT $LN26@Allocate

; 131  : 	const char* ptr = strrchr(source_file, '\\');

	push	92					; 0000005cH
	push	esi
	call	DWORD PTR __imp__strrchr
	add	esp, 8

; 132  : 	if (ptr) return ptr + 1;

	test	eax, eax
	jne	SHORT $LN69@Allocate

; 133  : 	ptr = strrchr(source_file, '/');

	push	47					; 0000002fH
	push	esi
	call	DWORD PTR __imp__strrchr
	add	esp, 8

; 134  : 	if (ptr) return ptr + 1;

	test	eax, eax
	je	SHORT $LN22@Allocate
$LN69@Allocate:
	lea	esi, DWORD PTR [eax+1]
$LN22@Allocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	-1
	push	esi
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 263  : 	if (source_file) strncpy_s(tag->SourceFile, FilePathStripper(source_file), _TRUNCATE);

	lea	eax, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	128					; 00000080H
	push	eax
	call	ebx
	add	esp, 16					; 00000010H
$LN26@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 264  : 	if (source_function) strncpy_s(tag->SourceFunction, source_function, _TRUNCATE);

	mov	eax, DWORD PTR _source_function$[esp+12]
	test	eax, eax
	je	SHORT $LN28@Allocate
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	-1
	push	eax
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 264  : 	if (source_function) strncpy_s(tag->SourceFunction, source_function, _TRUNCATE);

	lea	eax, DWORD PTR [edi+156]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	128					; 00000080H
	push	eax
	call	ebx
	add	esp, 16					; 00000010H
$LN28@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 265  : 	tag->SourceLine	= source_line;

	mov	eax, DWORD PTR _source_line$[esp+12]

; 135  : 	return source_file;
; 136  : }
; 137  : 
; 138  : const size_t MemoryTracker::GetMemoryTrackingCost()
; 139  : {
; 140  : 	// pointer size + sentinel size
; 141  : 	return sizeof(AllocationUnit*) + (SENTINEL_SIZE * sizeof(int32) * 2);
; 142  : };
; 143  : 
; 144  : AllocationUnit* MemoryTracker::FindAllocationUnit(void* memory)
; 145  : {
; 146  : 	void* actual = CalculateActualAddress(memory);
; 147  : 	int32* sentinel_start =  (int32*)((char*) actual + sizeof(AllocationUnit*));
; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation
; 149  : 	return *(AllocationUnit**) actual;
; 150  : };
; 151  : 
; 152  : void MemoryTracker::WipeMemoryWithPattern(AllocationUnit* unit, int32 pattern, size_t bias)
; 153  : {
; 154  : 
; 155  : #ifdef ALWAYS_WIPE_MEMORY
; 156  : 
; 157  : 	// fill the bulk of the allocation
; 158  : 	int32* iptr = (int32*)((char*)unit->ReportedAddress + bias);
; 159  : 	size_t length = unit->ReportedSize - bias;
; 160  : 	for (size_t i = 0; i < (length / 4); ++i)
; 161  : 	{
; 162  : 		*++iptr = pattern;
; 163  : 	};
; 164  : 
; 165  : 	// fill the remainder	
; 166  : 	char* cptr = (char*)iptr;
; 167  : 	for (size_t i = 0, shiftcount = 0; i < (length & 0x3); ++i, shiftcount += 8)
; 168  : 	{
; 169  : 		*++cptr = char(pattern & (0xFF << shiftcount) >> shiftcount);
; 170  : 	}
; 171  : #else
; 172  : 	UNUSED_VARIABLE(pattern);
; 173  : 	UNUSED_VARIABLE(bias);
; 174  : #endif
; 175  : 
; 176  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 177  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 178  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 179  : 	{
; 180  : 		*pre = PREFIX_PATTERN;
; 181  : 		*post = POSTFIX_PATTERN;
; 182  : 	};
; 183  : };
; 184  : 
; 185  : 
; 186  : bool MemoryTracker::ValidateAllocationUnit(AllocationUnit* unit)
; 187  : {
; 188  : 	// make sure the sentinels are untouched
; 189  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 190  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 191  : 	bool error_flag = false;
; 192  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 193  : 	{
; 194  : 		if (*pre != PREFIX_PATTERN)
; 195  : 		{
; 196  : 			// log this event maybe?
; 197  : 			error_flag = true;
; 198  : 		}
; 199  : 
; 200  : 		if (*post != POSTFIX_PATTERN) 
; 201  : 		{
; 202  : 			// this one too?
; 203  : 			error_flag = true;
; 204  : 		}
; 205  : 		
; 206  : 		// If you hit this assert, the sentinel before the allocation has been damaged 
; 207  : 		assert(*pre == PREFIX_PATTERN);
; 208  : 
; 209  : 		// If you hit this assert, the sentinel after the allocation has been damaged
; 210  : 		assert(*post == POSTFIX_PATTERN);
; 211  : 	};
; 212  : 	
; 213  : 	return !error_flag;
; 214  : };
; 215  : 
; 216  : extern DWORD TLSIndex; // HACK: Defined in dllmain_debug
; 217  : MemoryTrackerThreadLocalInformation* MemoryTracker::GetThreadLocalInformation()
; 218  : {
; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	push	DWORD PTR ?TLSIndex@@3KA		; TLSIndex
	mov	esi, DWORD PTR __imp__TlsGetValue@4

; 265  : 	tag->SourceLine	= source_line;

	mov	DWORD PTR [edi+284], eax

; 135  : 	return source_file;
; 136  : }
; 137  : 
; 138  : const size_t MemoryTracker::GetMemoryTrackingCost()
; 139  : {
; 140  : 	// pointer size + sentinel size
; 141  : 	return sizeof(AllocationUnit*) + (SENTINEL_SIZE * sizeof(int32) * 2);
; 142  : };
; 143  : 
; 144  : AllocationUnit* MemoryTracker::FindAllocationUnit(void* memory)
; 145  : {
; 146  : 	void* actual = CalculateActualAddress(memory);
; 147  : 	int32* sentinel_start =  (int32*)((char*) actual + sizeof(AllocationUnit*));
; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation
; 149  : 	return *(AllocationUnit**) actual;
; 150  : };
; 151  : 
; 152  : void MemoryTracker::WipeMemoryWithPattern(AllocationUnit* unit, int32 pattern, size_t bias)
; 153  : {
; 154  : 
; 155  : #ifdef ALWAYS_WIPE_MEMORY
; 156  : 
; 157  : 	// fill the bulk of the allocation
; 158  : 	int32* iptr = (int32*)((char*)unit->ReportedAddress + bias);
; 159  : 	size_t length = unit->ReportedSize - bias;
; 160  : 	for (size_t i = 0; i < (length / 4); ++i)
; 161  : 	{
; 162  : 		*++iptr = pattern;
; 163  : 	};
; 164  : 
; 165  : 	// fill the remainder	
; 166  : 	char* cptr = (char*)iptr;
; 167  : 	for (size_t i = 0, shiftcount = 0; i < (length & 0x3); ++i, shiftcount += 8)
; 168  : 	{
; 169  : 		*++cptr = char(pattern & (0xFF << shiftcount) >> shiftcount);
; 170  : 	}
; 171  : #else
; 172  : 	UNUSED_VARIABLE(pattern);
; 173  : 	UNUSED_VARIABLE(bias);
; 174  : #endif
; 175  : 
; 176  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 177  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 178  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 179  : 	{
; 180  : 		*pre = PREFIX_PATTERN;
; 181  : 		*post = POSTFIX_PATTERN;
; 182  : 	};
; 183  : };
; 184  : 
; 185  : 
; 186  : bool MemoryTracker::ValidateAllocationUnit(AllocationUnit* unit)
; 187  : {
; 188  : 	// make sure the sentinels are untouched
; 189  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 190  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 191  : 	bool error_flag = false;
; 192  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 193  : 	{
; 194  : 		if (*pre != PREFIX_PATTERN)
; 195  : 		{
; 196  : 			// log this event maybe?
; 197  : 			error_flag = true;
; 198  : 		}
; 199  : 
; 200  : 		if (*post != POSTFIX_PATTERN) 
; 201  : 		{
; 202  : 			// this one too?
; 203  : 			error_flag = true;
; 204  : 		}
; 205  : 		
; 206  : 		// If you hit this assert, the sentinel before the allocation has been damaged 
; 207  : 		assert(*pre == PREFIX_PATTERN);
; 208  : 
; 209  : 		// If you hit this assert, the sentinel after the allocation has been damaged
; 210  : 		assert(*post == POSTFIX_PATTERN);
; 211  : 	};
; 212  : 	
; 213  : 	return !error_flag;
; 214  : };
; 215  : 
; 216  : extern DWORD TLSIndex; // HACK: Defined in dllmain_debug
; 217  : MemoryTrackerThreadLocalInformation* MemoryTracker::GetThreadLocalInformation()
; 218  : {
; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	call	esi

; 266  : 
; 267  : 	{
; 268  : 	// Since we are getting the tracking info here anyways we could optimize this function to just use the info from here
; 269  : 	MemoryTrackerThreadLocalInformation* info = GetThreadLocalInformation();
; 270  : 	strcpy_s(tag->AllocationTag, sizeof(tag->AllocationTag), info->AllocationTagStack[info->CurrentAllocationTag]);

	mov	ecx, DWORD PTR [eax+1284]
	shl	ecx, 5
	add	ecx, 260				; 00000104H
	add	eax, ecx
	push	eax
	lea	eax, DWORD PTR [edi+296]
	push	32					; 00000020H
	push	eax
	call	DWORD PTR __imp__strcpy_s

; 271  : 	}
; 272  : 
; 273  : 	tag->AllocationType = type;

	mov	DWORD PTR [edi+288], ebp

; 274  : 	tag->AllocationNumber = _InterlockedIncrement((long*)&CurrentAllocationCount);

	mov	ecx, OFFSET ?CurrentAllocationCount@MemoryTracker@@1JA ; MemoryTracker::CurrentAllocationCount
	mov	eax, 1
	lock	 xadd	 DWORD PTR [ecx], eax
	inc	eax
	mov	DWORD PTR [edi+292], eax

; 275  : 
; 276  : 	tag->BreakOnFree = false;
; 277  : 	tag->BreakOnRealloc = false;
; 278  : 
; 279  : #if DETAILED_LEAK_LOGS
; 280  : 	// Quick hack to avoid going out of stack bounds. TODO: Find a better solution.
; 281  : 	memcpy(tag->stack, _AddressOfReturnAddress(), min(0x1000 - (uint)_AddressOfReturnAddress() & (0x1000-1), sizeof(tag->stack)));
; 282  : #endif
; 283  : 
; 284  : 	// Store the allocation unit tag address within the allocation memory
; 285  : 	*(AllocationUnit**)tag->ActualAddress = tag;

	mov	eax, DWORD PTR [edi+12]
	mov	WORD PTR [edi+328], 0

; 286  : 
; 287  : #ifdef LARGE_ALLOCATION_DEBUG_STATS
; 288  : 	if (tag->ReportedSize > (1 << 13)) // big memory
; 289  : 	{
; 290  : 		char buffer[512];
; 291  : 		sprintf(buffer, 
; 292  : 			"%.3f\talloc:\t(%dB) <%.3fMiB> %s %s:%d\n", 
; 293  : 			(timeGetTime() - StartTime) / 1000.0f, 
; 294  : 			tag->ReportedSize, 
; 295  : 			FastAllocatorGeneral::Get_Allocator()->GetTotalMemoryUsage() / 1024.f / 1024.0f, 
; 296  : 			tag->SourceFunction, 
; 297  : 			tag->SourceFile, 
; 298  : 			tag->SourceLine);
; 299  : 		OutputDebugStringA(buffer);
; 300  : 	}
; 301  : #endif
; 302  : 
; 303  : 	// We'll wipe the memory here with our "Unused" pattern so we can later estimate how much of that allocated
; 304  : 	// memory was actually "used"
; 305  : 	WipeMemoryWithPattern(tag, UNUSED_PATTERN);

	add	esp, 8
	mov	ecx, edi
	mov	DWORD PTR [eax], edi
	call	?WipeMemoryWithPattern@MemoryTracker@@KAXPAVAllocationUnit@@HI@Z ; MemoryTracker::WipeMemoryWithPattern
	add	esp, 4

; 306  : 
; 307  : 	// And we'll wipe the memory here *again* if it's allocated via calloc, which expects all the memory to be zero-init'd
; 308  : 	if (type == AllocType_Calloc) memset(tag->ReportedAddress, 0x00, tag->ReportedSize);

	cmp	ebp, 4
	jne	SHORT $LN1@Allocate
	push	DWORD PTR [edi+24]
	push	0
	push	DWORD PTR [edi+20]
	call	_memset
	add	esp, 12					; 0000000cH
$LN1@Allocate:

; 135  : 	return source_file;
; 136  : }
; 137  : 
; 138  : const size_t MemoryTracker::GetMemoryTrackingCost()
; 139  : {
; 140  : 	// pointer size + sentinel size
; 141  : 	return sizeof(AllocationUnit*) + (SENTINEL_SIZE * sizeof(int32) * 2);
; 142  : };
; 143  : 
; 144  : AllocationUnit* MemoryTracker::FindAllocationUnit(void* memory)
; 145  : {
; 146  : 	void* actual = CalculateActualAddress(memory);
; 147  : 	int32* sentinel_start =  (int32*)((char*) actual + sizeof(AllocationUnit*));
; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation
; 149  : 	return *(AllocationUnit**) actual;
; 150  : };
; 151  : 
; 152  : void MemoryTracker::WipeMemoryWithPattern(AllocationUnit* unit, int32 pattern, size_t bias)
; 153  : {
; 154  : 
; 155  : #ifdef ALWAYS_WIPE_MEMORY
; 156  : 
; 157  : 	// fill the bulk of the allocation
; 158  : 	int32* iptr = (int32*)((char*)unit->ReportedAddress + bias);
; 159  : 	size_t length = unit->ReportedSize - bias;
; 160  : 	for (size_t i = 0; i < (length / 4); ++i)
; 161  : 	{
; 162  : 		*++iptr = pattern;
; 163  : 	};
; 164  : 
; 165  : 	// fill the remainder	
; 166  : 	char* cptr = (char*)iptr;
; 167  : 	for (size_t i = 0, shiftcount = 0; i < (length & 0x3); ++i, shiftcount += 8)
; 168  : 	{
; 169  : 		*++cptr = char(pattern & (0xFF << shiftcount) >> shiftcount);
; 170  : 	}
; 171  : #else
; 172  : 	UNUSED_VARIABLE(pattern);
; 173  : 	UNUSED_VARIABLE(bias);
; 174  : #endif
; 175  : 
; 176  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 177  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 178  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 179  : 	{
; 180  : 		*pre = PREFIX_PATTERN;
; 181  : 		*post = POSTFIX_PATTERN;
; 182  : 	};
; 183  : };
; 184  : 
; 185  : 
; 186  : bool MemoryTracker::ValidateAllocationUnit(AllocationUnit* unit)
; 187  : {
; 188  : 	// make sure the sentinels are untouched
; 189  : 	int32 *pre = (int32*)CalculatePrefixSentinelStartAddress(unit);
; 190  : 	int32 *post = (int32*)CalculatePostfixSentinelStartAddress(unit);
; 191  : 	bool error_flag = false;
; 192  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)
; 193  : 	{
; 194  : 		if (*pre != PREFIX_PATTERN)
; 195  : 		{
; 196  : 			// log this event maybe?
; 197  : 			error_flag = true;
; 198  : 		}
; 199  : 
; 200  : 		if (*post != POSTFIX_PATTERN) 
; 201  : 		{
; 202  : 			// this one too?
; 203  : 			error_flag = true;
; 204  : 		}
; 205  : 		
; 206  : 		// If you hit this assert, the sentinel before the allocation has been damaged 
; 207  : 		assert(*pre == PREFIX_PATTERN);
; 208  : 
; 209  : 		// If you hit this assert, the sentinel after the allocation has been damaged
; 210  : 		assert(*post == POSTFIX_PATTERN);
; 211  : 	};
; 212  : 	
; 213  : 	return !error_flag;
; 214  : };
; 215  : 
; 216  : extern DWORD TLSIndex; // HACK: Defined in dllmain_debug
; 217  : MemoryTrackerThreadLocalInformation* MemoryTracker::GetThreadLocalInformation()
; 218  : {
; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	push	DWORD PTR ?TLSIndex@@3KA		; TLSIndex
	call	esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	-1
	push	OFFSET ??_C@_0P@OLMEFAAF@?$CIUnknown?5File?$CJ?$AA@
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 225  : 	MemoryTrackerThreadLocalInformation* info = GetThreadLocalInformation();

	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	128					; 00000080H
	push	esi
	call	ebx
	push	-1
	push	OFFSET ??_C@_0BD@OJFFOEJL@?$CIUnknown?5Function?$CJ?$AA@
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 227  : 	strncpy_s(info->CurrentSourceFunction, source_function ? source_function : "(Unknown Function)", _TRUNCATE);

	lea	eax, DWORD PTR [esi+128]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	128					; 00000080H
	push	eax
	call	ebx
	add	esp, 32					; 00000020H
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 228  : 	info->CurrentSourceLine = source_line;

	mov	DWORD PTR [esi+256], -1
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	mov	eax, OFFSET _MemoryTrackerCS
	lock	 bts	 DWORD PTR [eax], 0
	jae	SHORT $LN65@Allocate
$LL52@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	lock	 bts	 DWORD PTR [eax], 0
	jb	SHORT $LL52@Allocate
$LN65@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 138  : 		this->InsertAfter(Tail, node_to_insert);

	push	edi
	push	DWORD PTR _Tags+4
	call	?InsertAfter@DListBase@@QAEXPAVDLNodeBase@@0@Z ; DListBase::InsertAfter
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 32   : 		Flag = 0;

	mov	DWORD PTR _MemoryTrackerCS, 0
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 320  : 	return tag->ReportedAddress;

	mov	eax, DWORD PTR [edi+20]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 321  : };

	ret	0
?Allocate@MemoryTracker@@SAPAXIW4AllocType@@PBD1H@Z ENDP ; MemoryTracker::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?Reallocate@MemoryTracker@@SAPAXPAXIPBD1H@Z
_TEXT	SEGMENT
_new_memory$1$ = -4					; size = 4
_source_file$ = 8					; size = 4
_source_function$ = 12					; size = 4
_source_line$ = 16					; size = 4
?Reallocate@MemoryTracker@@SAPAXPAXIPBD1H@Z PROC	; MemoryTracker::Reallocate, COMDAT
; _memory$ = ecx
; _size$ = edx

; 324  : {

	push	ecx
	push	ebp
	push	esi
	mov	esi, ecx
	mov	ebp, edx

; 325  : 	// standard defines realloc as returning malloc(size) if memblock is NULL
; 326  : 	if (!memory) return MemoryTracker::Allocate(size, AllocType_Realloc, source_file, source_function, source_line);

	test	esi, esi
	jne	SHORT $LN3@Reallocate
	push	DWORD PTR _source_line$[esp+8]
	lea	edx, DWORD PTR [ecx+5]
	push	DWORD PTR _source_function$[esp+12]
	mov	ecx, ebp
	push	DWORD PTR _source_file$[esp+16]
	call	?Allocate@MemoryTracker@@SAPAXIW4AllocType@@PBD1H@Z ; MemoryTracker::Allocate
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebp

; 365  : };

	pop	ecx
	ret	0
$LN3@Reallocate:
	push	edi

; 327  : 
; 328  : 	// standard defines realloc as calling free(memory) and returning NULL if size is NULL
; 329  : 	if (!size)

	test	ebp, ebp
	jne	$LN2@Reallocate

; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation

	cmp	DWORD PTR [esi-32], -1163005939		; baadf00dH
	jne	$LN141@Reallocate

; 149  : 	return *(AllocationUnit**) actual;

	mov	esi, DWORD PTR [esi-36]

; 366  : 
; 367  : void MemoryTracker::Free(void* memory, const DeallocType type, const char* source_file, const char* source_function, const int source_line)
; 368  : {
; 369  : 	UNUSED_VARIABLE(source_file);
; 370  : 	UNUSED_VARIABLE(source_function);
; 371  : 	UNUSED_VARIABLE(source_line);
; 372  : 	if (!memory) return; // standard defines free(NULL) as basically a no-op, so do so here.
; 373  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 374  : 
; 375  : 	// If you hit this assert, you tried to deallocate memory that was either not allocated with this allocator 
; 376  : 	// or so badly damaged that it failed the preliminary test
; 377  : 	assert(tag != NULL);

	test	esi, esi
	je	$LN141@Reallocate

; 378  : 
; 379  : 	// We've warned the user about the tag being NULL, let's not actually try to do anything further with the memory
; 380  : 	if (tag == NULL) return;
; 381  : 
; 382  : 	// If you hit this assert, the memory that is about to be deallocated is damaged, but you should have seen
; 383  : 	// an earlier assert in ValidateAllocationUnit
; 384  : 	assert(ValidateAllocationUnit(tag));

	mov	ecx, esi
	call	?ValidateAllocationUnit@MemoryTracker@@KA_NPAVAllocationUnit@@@Z ; MemoryTracker::ValidateAllocationUnit
	mov	edi, DWORD PTR __imp___wassert
	test	al, al
	jne	SHORT $LN15@Reallocate
	push	384					; 00000180H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1DI@EPMGAHAB@?$AAV?$AAa?$AAl?$AAi?$AAd?$AAa?$AAt?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CI?$AAt?$AAa?$AAg?$AA?$CJ?$AA?$AA@
	call	edi
	add	esp, 12					; 0000000cH
$LN15@Reallocate:

; 385  : 
; 386  : 	// If you hit this assert, then this deallocation call was made from a source that isn't setup to use our
; 387  : 	// memory tracking system. Use the callstack to locate the source and include our memory tracker header.
; 388  : 	assert(type != DeallocType_Unknown);
; 389  : 
; 390  : 	// If you hit this assert, you were trying to deallocate RAM that wasn't allocated in a way that's compatible
; 391  : 	// with the deallocation method requested. Simply put, your allocation/deallocation calls are mismatched.
; 392  : 	assert (
; 393  : 		(tag->AllocationType == AllocType_New		&& type == DeallocType_Delete) ||
; 394  : 		(tag->AllocationType == AllocType_VectorNew	&& type == DeallocType_VectorDelete) ||
; 395  : 		(tag->AllocationType == AllocType_Malloc	&& type == DeallocType_Free) ||
; 396  : 		(tag->AllocationType == AllocType_Calloc	&& type == DeallocType_Free) ||
; 397  : 		(tag->AllocationType == AllocType_Realloc	&& type == DeallocType_Free) ||
; 398  : 		(tag->AllocationType == AllocType_Malloc	&& type == DeallocType_Realloc) ||
; 399  : 		(tag->AllocationType == AllocType_Calloc	&& type == DeallocType_Realloc) ||
; 400  : 		(tag->AllocationType == AllocType_Realloc	&& type == DeallocType_Realloc) ||
; 401  : 		(tag->AllocationType == AllocType_Unvalidated) || 
; 402  : 		(type == DeallocType_Unvalidated) 	 
; 403  : 	);

	mov	eax, DWORD PTR [esi+288]
	cmp	eax, 3
	je	SHORT $LN19@Reallocate
	cmp	eax, 4
	je	SHORT $LN19@Reallocate
	cmp	eax, 5
	je	SHORT $LN19@Reallocate
	cmp	eax, 6
	je	SHORT $LN19@Reallocate
	push	403					; 00000193H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1FGC@DNPNIFOO@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@
	call	edi
	add	esp, 12					; 0000000cH
$LN19@Reallocate:

; 404  : 
; 405  : 	// If you hit this assert, you requested that we break when this piece of memory came through to be deallocated/reallocated
; 406  : 	assert(!(tag->BreakOnFree && type == DeallocType_Free) || !(tag->BreakOnRealloc && type == DeallocType_Realloc));
; 407  : 	
; 408  : #ifdef LARGE_ALLOCATION_DEBUG_STATS
; 409  : 	if (tag->ReportedSize > (1 << 13)) // big memory
; 410  : 	{
; 411  : 		char buffer[512];
; 412  : 		sprintf(buffer, "%.3f\tfree:\t(%d bytes) <%.3fMiB> %s %s:%d\n", 
; 413  : 			(timeGetTime() - StartTime) / 1000.0f, 
; 414  : 			tag->ReportedSize, 
; 415  : 			FastAllocatorGeneral::Get_Allocator()->GetTotalMemoryUsage() / 1024.f / 1024.0f, 
; 416  : 			tag->SourceFunction, 
; 417  : 			tag->SourceFile, 
; 418  : 			tag->SourceLine);
; 419  : 		OutputDebugStringA(buffer);
; 420  : 	}
; 421  : #endif
; 422  : 	
; 423  : 	// We'll wipe the memory here with our "Released" pattern even though it likely won't do much good.
; 424  : 	WipeMemoryWithPattern(tag, RELEASED_PATTERN);

	push	ecx
	mov	ecx, esi
	call	?WipeMemoryWithPattern@MemoryTracker@@KAXPAVAllocationUnit@@HI@Z ; MemoryTracker::WipeMemoryWithPattern

; 425  : 
; 426  : 	// Nuke the allocation unit tag address
; 427  : 	*(AllocationUnit**)tag->ActualAddress = NULL;

	mov	eax, DWORD PTR [esi+12]
	add	esp, 4
	mov	DWORD PTR [eax], 0

; 428  : 
; 429  : 	// Free the actual memory
; 430  : 	FastAllocatorGeneral::Get_Allocator()->Free(tag->ActualAddress);

	push	DWORD PTR [esi+12]
	mov	ecx, DWORD PTR ___general_allocator
	call	?Free@FastAllocatorGeneral@@QAEXPAX@Z	; FastAllocatorGeneral::Free

; 431  : 
; 432  : 	// Clearing the tracking information insures that if at some later time somebody calls our memory tracker
; 433  : 	// from an unknown source, we don't think it was the last allocation.
; 434  : 	ClearThreadLocalInformation();

	call	?ClearThreadLocalInformation@MemoryTracker@@KAXXZ ; MemoryTracker::ClearThreadLocalInformation
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	mov	eax, OFFSET _MemoryTrackerCS
	lock	 bts	 DWORD PTR [eax], 0
	jae	SHORT $LN133@Reallocate
	npad	1
$LL47@Reallocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	lock	 bts	 DWORD PTR [eax], 0
	jb	SHORT $LL47@Reallocate
$LN133@Reallocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 112  : 		if (node->Next) node->Next->Previous = node->Previous;

	mov	edx, DWORD PTR [esi]

; 118  : 		return node;
; 119  : 	};
; 120  : 
; 121  : 	DLNodeBase* GetHead()
; 122  : 	{
; 123  : 		return Head;
; 124  : 	};
; 125  : 
; 126  : 	DLNodeBase* GetTail()
; 127  : 	{
; 128  : 		return Head;
; 129  : 	};
; 130  : 
; 131  : 	void PushHead(DLNodeBase* node_to_insert)
; 132  : 	{
; 133  : 		this->InsertBefore(Head, node_to_insert);
; 134  : 	};
; 135  : 	
; 136  : 	void PushTail(DLNodeBase* node_to_insert)
; 137  : 	{
; 138  : 		this->InsertAfter(Tail, node_to_insert);
; 139  : 	};
; 140  : 
; 141  : 	DLNodeBase* PopHead()
; 142  : 	{
; 143  : 		return this->Head ? this->Remove(Head) : NULL;
; 144  : 	};
; 145  : 
; 146  : 	DLNodeBase* PopTail()
; 147  : 	{
; 148  : 		return this->Tail? this->Remove(Tail) : NULL;
; 149  : 	};
; 150  : };
; 151  : 
; 152  : inline DLNodeBase::DLNodeBase(): Next(NULL), Previous(NULL), List(NULL)
; 153  : {
; 154  : 
; 155  : };
; 156  : 
; 157  : inline DLNodeBase::~DLNodeBase()
; 158  : {
; 159  : 	assert(this->List == NULL); // If list is not NULL, then you forgot to remove this item before deleting it.
; 160  : };
; 161  : 
; 162  : inline DLNodeBase* DLNodeBase::GetNextNode()
; 163  : {
; 164  : 	return this->Next;
; 165  : };
; 166  : 
; 167  : inline DLNodeBase* DLNodeBase::GetPreviousNode()
; 168  : {
; 169  : 	return this->Previous;
; 170  : };
; 171  : 
; 172  : inline DListBase* DLNodeBase::GetList()
; 173  : {
; 174  : 	return this->List;
; 175  : };
; 176  : 
; 177  : inline void DLNodeBase::InsertBefore(DLNodeBase* node)
; 178  : {
; 179  : 	List->InsertBefore(node, this);
; 180  : };
; 181  : 
; 182  : inline void DLNodeBase::InsertAfter(DLNodeBase* node)
; 183  : {
; 184  : 	List->InsertAfter(node, this);
; 185  : };
; 186  : 
; 187  : inline void DLNodeBase::Remove()
; 188  : {
; 189  : 	List->Remove(this);

	mov	ecx, DWORD PTR [esi+8]

; 112  : 		if (node->Next) node->Next->Previous = node->Previous;

	test	edx, edx
	je	SHORT $LN57@Reallocate
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax
$LN57@Reallocate:

; 113  : 		if (node->Previous) node->Previous->Next = node->Next;

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	je	SHORT $LN56@Reallocate
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx], eax
$LN56@Reallocate:

; 114  : 		if (node == this->Head) this->Head = node->Next;

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN55@Reallocate
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN55@Reallocate:

; 115  : 		if (node == this->Tail) this->Tail = node->Previous;

	cmp	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN54@Reallocate
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax
$LN54@Reallocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 440  : 		delete tag;

	push	ecx
	mov	ecx, esi
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 117  : 		node->List = NULL;

	mov	DWORD PTR [esi+8], 0
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 440  : 		delete tag;

	call	??_GAllocationUnit@@QAEPAXI@Z
	pop	edi
	pop	esi
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 32   : 		Flag = 0;

	mov	DWORD PTR _MemoryTrackerCS, 0
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 332  : 		return NULL;

	xor	eax, eax
	pop	ebp

; 365  : };

	pop	ecx
	ret	0
$LN141@Reallocate:

; 366  : 
; 367  : void MemoryTracker::Free(void* memory, const DeallocType type, const char* source_file, const char* source_function, const int source_line)
; 368  : {
; 369  : 	UNUSED_VARIABLE(source_file);
; 370  : 	UNUSED_VARIABLE(source_function);
; 371  : 	UNUSED_VARIABLE(source_line);
; 372  : 	if (!memory) return; // standard defines free(NULL) as basically a no-op, so do so here.
; 373  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 374  : 
; 375  : 	// If you hit this assert, you tried to deallocate memory that was either not allocated with this allocator 
; 376  : 	// or so badly damaged that it failed the preliminary test
; 377  : 	assert(tag != NULL);

	push	377					; 00000179H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1BI@NNABAJNA@?$AAt?$AAa?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH

; 332  : 		return NULL;

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebp

; 365  : };

	pop	ecx
	ret	0
$LN2@Reallocate:

; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation

	cmp	DWORD PTR [esi-32], -1163005939		; baadf00dH
	push	ebx
	jne	$LN142@Reallocate

; 149  : 	return *(AllocationUnit**) actual;

	mov	ebx, DWORD PTR [esi-36]

; 333  : 	}
; 334  : 
; 335  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 336  : 
; 337  : 	// If you hit this assert, you tried to reallocate memory that was either not allocated with this allocator 
; 338  : 	// or so badly damaged that it failed the preliminary test
; 339  : 	assert(tag != NULL);

	test	ebx, ebx
	je	$LN142@Reallocate

; 343  : 
; 344  : 	// If you hit this assert, the memory that is about to be reallocated is damaged, but you should have seen
; 345  : 	// an earlier assert in ValidateAllocationUnit
; 346  : 	assert(ValidateAllocationUnit(tag));

	mov	ecx, ebx
	call	?ValidateAllocationUnit@MemoryTracker@@KA_NPAVAllocationUnit@@@Z ; MemoryTracker::ValidateAllocationUnit
	mov	edi, DWORD PTR __imp___wassert
	test	al, al
	jne	SHORT $LN7@Reallocate
	push	346					; 0000015aH
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1DI@EPMGAHAB@?$AAV?$AAa?$AAl?$AAi?$AAd?$AAa?$AAt?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CI?$AAt?$AAa?$AAg?$AA?$CJ?$AA?$AA@
	call	edi
	add	esp, 12					; 0000000cH
$LN7@Reallocate:

; 347  : 
; 348  : 	// If you hit this assert, you were trying to reallocate RAM that wasn't allocated in a way that's compatible
; 349  : 	// with reallocation. Simply put, you can't use new/new[] with realloc
; 350  : 	assert((tag->AllocationType != AllocType_New) && (tag->AllocationType != AllocType_VectorNew));

	mov	eax, DWORD PTR [ebx+288]
	cmp	eax, 1
	je	SHORT $LN8@Reallocate
	cmp	eax, 2
	jne	SHORT $LN9@Reallocate
$LN8@Reallocate:
	push	350					; 0000015eH
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1KO@HLDIACEN@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@
	call	edi
	add	esp, 12					; 0000000cH
$LN9@Reallocate:

; 351  : 
; 352  : 	// Allocate the new memory and copy over the existing contents
; 353  : 	void* new_memory = MemoryTracker::Allocate(size, AllocType_Realloc, source_file, source_function, source_line);

	push	DWORD PTR _source_line$[esp+16]
	mov	edx, 5
	push	DWORD PTR _source_function$[esp+20]
	mov	ecx, ebp
	push	DWORD PTR _source_file$[esp+24]
	call	?Allocate@MemoryTracker@@SAPAXIW4AllocType@@PBD1H@Z ; MemoryTracker::Allocate

; 354  : 	memcpy(new_memory, memory, size);

	push	ebp
	mov	ebp, eax
	push	esi
	push	ebp
	mov	DWORD PTR _new_memory$1$[esp+44], eax
	call	_memcpy
	add	esp, 24					; 00000018H

; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation

	cmp	DWORD PTR [ebp-32], -1163005939		; baadf00dH
	je	SHORT $LN70@Reallocate
	xor	ecx, ecx
	jmp	SHORT $LN71@Reallocate
$LN70@Reallocate:

; 149  : 	return *(AllocationUnit**) actual;

	mov	ecx, DWORD PTR [ebp-36]
$LN71@Reallocate:

; 355  : 
; 356  : 	// Copy over BreakOn* info
; 357  : 	AllocationUnit* new_tag = FindAllocationUnit(new_memory);
; 358  : 	new_tag->BreakOnFree = tag->BreakOnFree;

	mov	al, BYTE PTR [ebx+328]
	mov	BYTE PTR [ecx+328], al

; 359  : 	new_tag->BreakOnRealloc = tag->BreakOnRealloc;

	mov	al, BYTE PTR [ebx+329]
	mov	BYTE PTR [ecx+329], al

; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation

	cmp	DWORD PTR [esi-32], -1163005939		; baadf00dH
	jne	$LN143@Reallocate

; 149  : 	return *(AllocationUnit**) actual;

	mov	esi, DWORD PTR [esi-36]

; 366  : 
; 367  : void MemoryTracker::Free(void* memory, const DeallocType type, const char* source_file, const char* source_function, const int source_line)
; 368  : {
; 369  : 	UNUSED_VARIABLE(source_file);
; 370  : 	UNUSED_VARIABLE(source_function);
; 371  : 	UNUSED_VARIABLE(source_line);
; 372  : 	if (!memory) return; // standard defines free(NULL) as basically a no-op, so do so here.
; 373  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 374  : 
; 375  : 	// If you hit this assert, you tried to deallocate memory that was either not allocated with this allocator 
; 376  : 	// or so badly damaged that it failed the preliminary test
; 377  : 	assert(tag != NULL);

	test	esi, esi
	je	$LN143@Reallocate

; 378  : 
; 379  : 	// We've warned the user about the tag being NULL, let's not actually try to do anything further with the memory
; 380  : 	if (tag == NULL) return;
; 381  : 
; 382  : 	// If you hit this assert, the memory that is about to be deallocated is damaged, but you should have seen
; 383  : 	// an earlier assert in ValidateAllocationUnit
; 384  : 	assert(ValidateAllocationUnit(tag));

	mov	ecx, esi
	call	?ValidateAllocationUnit@MemoryTracker@@KA_NPAVAllocationUnit@@@Z ; MemoryTracker::ValidateAllocationUnit
	test	al, al
	jne	SHORT $LN80@Reallocate
	push	384					; 00000180H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1DI@EPMGAHAB@?$AAV?$AAa?$AAl?$AAi?$AAd?$AAa?$AAt?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CI?$AAt?$AAa?$AAg?$AA?$CJ?$AA?$AA@
	call	edi
	add	esp, 12					; 0000000cH
$LN80@Reallocate:

; 385  : 
; 386  : 	// If you hit this assert, then this deallocation call was made from a source that isn't setup to use our
; 387  : 	// memory tracking system. Use the callstack to locate the source and include our memory tracker header.
; 388  : 	assert(type != DeallocType_Unknown);
; 389  : 
; 390  : 	// If you hit this assert, you were trying to deallocate RAM that wasn't allocated in a way that's compatible
; 391  : 	// with the deallocation method requested. Simply put, your allocation/deallocation calls are mismatched.
; 392  : 	assert (
; 393  : 		(tag->AllocationType == AllocType_New		&& type == DeallocType_Delete) ||
; 394  : 		(tag->AllocationType == AllocType_VectorNew	&& type == DeallocType_VectorDelete) ||
; 395  : 		(tag->AllocationType == AllocType_Malloc	&& type == DeallocType_Free) ||
; 396  : 		(tag->AllocationType == AllocType_Calloc	&& type == DeallocType_Free) ||
; 397  : 		(tag->AllocationType == AllocType_Realloc	&& type == DeallocType_Free) ||
; 398  : 		(tag->AllocationType == AllocType_Malloc	&& type == DeallocType_Realloc) ||
; 399  : 		(tag->AllocationType == AllocType_Calloc	&& type == DeallocType_Realloc) ||
; 400  : 		(tag->AllocationType == AllocType_Realloc	&& type == DeallocType_Realloc) ||
; 401  : 		(tag->AllocationType == AllocType_Unvalidated) || 
; 402  : 		(type == DeallocType_Unvalidated) 	 
; 403  : 	);

	mov	eax, DWORD PTR [esi+288]
	cmp	eax, 3
	je	SHORT $LN84@Reallocate
	cmp	eax, 4
	je	SHORT $LN84@Reallocate
	cmp	eax, 5
	je	SHORT $LN84@Reallocate
	cmp	eax, 6
	je	SHORT $LN84@Reallocate
	push	403					; 00000193H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1FGC@DNPNIFOO@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@
	call	edi
	add	esp, 12					; 0000000cH
$LN84@Reallocate:

; 404  : 
; 405  : 	// If you hit this assert, you requested that we break when this piece of memory came through to be deallocated/reallocated
; 406  : 	assert(!(tag->BreakOnFree && type == DeallocType_Free) || !(tag->BreakOnRealloc && type == DeallocType_Realloc));
; 407  : 	
; 408  : #ifdef LARGE_ALLOCATION_DEBUG_STATS
; 409  : 	if (tag->ReportedSize > (1 << 13)) // big memory
; 410  : 	{
; 411  : 		char buffer[512];
; 412  : 		sprintf(buffer, "%.3f\tfree:\t(%d bytes) <%.3fMiB> %s %s:%d\n", 
; 413  : 			(timeGetTime() - StartTime) / 1000.0f, 
; 414  : 			tag->ReportedSize, 
; 415  : 			FastAllocatorGeneral::Get_Allocator()->GetTotalMemoryUsage() / 1024.f / 1024.0f, 
; 416  : 			tag->SourceFunction, 
; 417  : 			tag->SourceFile, 
; 418  : 			tag->SourceLine);
; 419  : 		OutputDebugStringA(buffer);
; 420  : 	}
; 421  : #endif
; 422  : 	
; 423  : 	// We'll wipe the memory here with our "Released" pattern even though it likely won't do much good.
; 424  : 	WipeMemoryWithPattern(tag, RELEASED_PATTERN);

	push	ecx
	mov	ecx, esi
	call	?WipeMemoryWithPattern@MemoryTracker@@KAXPAVAllocationUnit@@HI@Z ; MemoryTracker::WipeMemoryWithPattern

; 425  : 
; 426  : 	// Nuke the allocation unit tag address
; 427  : 	*(AllocationUnit**)tag->ActualAddress = NULL;

	mov	eax, DWORD PTR [esi+12]
	add	esp, 4
	mov	DWORD PTR [eax], 0

; 428  : 
; 429  : 	// Free the actual memory
; 430  : 	FastAllocatorGeneral::Get_Allocator()->Free(tag->ActualAddress);

	push	DWORD PTR [esi+12]
	mov	ecx, DWORD PTR ___general_allocator
	call	?Free@FastAllocatorGeneral@@QAEXPAX@Z	; FastAllocatorGeneral::Free

; 431  : 
; 432  : 	// Clearing the tracking information insures that if at some later time somebody calls our memory tracker
; 433  : 	// from an unknown source, we don't think it was the last allocation.
; 434  : 	ClearThreadLocalInformation();

	call	?ClearThreadLocalInformation@MemoryTracker@@KAXXZ ; MemoryTracker::ClearThreadLocalInformation
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	mov	eax, OFFSET _MemoryTrackerCS
	lock	 bts	 DWORD PTR [eax], 0
	jae	SHORT $LN134@Reallocate
$LL112@Reallocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	lock	 bts	 DWORD PTR [eax], 0
	jb	SHORT $LL112@Reallocate
$LN134@Reallocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 112  : 		if (node->Next) node->Next->Previous = node->Previous;

	mov	edx, DWORD PTR [esi]

; 118  : 		return node;
; 119  : 	};
; 120  : 
; 121  : 	DLNodeBase* GetHead()
; 122  : 	{
; 123  : 		return Head;
; 124  : 	};
; 125  : 
; 126  : 	DLNodeBase* GetTail()
; 127  : 	{
; 128  : 		return Head;
; 129  : 	};
; 130  : 
; 131  : 	void PushHead(DLNodeBase* node_to_insert)
; 132  : 	{
; 133  : 		this->InsertBefore(Head, node_to_insert);
; 134  : 	};
; 135  : 	
; 136  : 	void PushTail(DLNodeBase* node_to_insert)
; 137  : 	{
; 138  : 		this->InsertAfter(Tail, node_to_insert);
; 139  : 	};
; 140  : 
; 141  : 	DLNodeBase* PopHead()
; 142  : 	{
; 143  : 		return this->Head ? this->Remove(Head) : NULL;
; 144  : 	};
; 145  : 
; 146  : 	DLNodeBase* PopTail()
; 147  : 	{
; 148  : 		return this->Tail? this->Remove(Tail) : NULL;
; 149  : 	};
; 150  : };
; 151  : 
; 152  : inline DLNodeBase::DLNodeBase(): Next(NULL), Previous(NULL), List(NULL)
; 153  : {
; 154  : 
; 155  : };
; 156  : 
; 157  : inline DLNodeBase::~DLNodeBase()
; 158  : {
; 159  : 	assert(this->List == NULL); // If list is not NULL, then you forgot to remove this item before deleting it.
; 160  : };
; 161  : 
; 162  : inline DLNodeBase* DLNodeBase::GetNextNode()
; 163  : {
; 164  : 	return this->Next;
; 165  : };
; 166  : 
; 167  : inline DLNodeBase* DLNodeBase::GetPreviousNode()
; 168  : {
; 169  : 	return this->Previous;
; 170  : };
; 171  : 
; 172  : inline DListBase* DLNodeBase::GetList()
; 173  : {
; 174  : 	return this->List;
; 175  : };
; 176  : 
; 177  : inline void DLNodeBase::InsertBefore(DLNodeBase* node)
; 178  : {
; 179  : 	List->InsertBefore(node, this);
; 180  : };
; 181  : 
; 182  : inline void DLNodeBase::InsertAfter(DLNodeBase* node)
; 183  : {
; 184  : 	List->InsertAfter(node, this);
; 185  : };
; 186  : 
; 187  : inline void DLNodeBase::Remove()
; 188  : {
; 189  : 	List->Remove(this);

	mov	ecx, DWORD PTR [esi+8]

; 112  : 		if (node->Next) node->Next->Previous = node->Previous;

	test	edx, edx
	je	SHORT $LN122@Reallocate
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax
$LN122@Reallocate:

; 113  : 		if (node->Previous) node->Previous->Next = node->Next;

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	je	SHORT $LN121@Reallocate
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx], eax
$LN121@Reallocate:

; 114  : 		if (node == this->Head) this->Head = node->Next;

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN120@Reallocate
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN120@Reallocate:

; 115  : 		if (node == this->Tail) this->Tail = node->Previous;

	cmp	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN119@Reallocate
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax
$LN119@Reallocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 440  : 		delete tag;

	push	ecx
	mov	ecx, esi
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 117  : 		node->List = NULL;

	mov	DWORD PTR [esi+8], 0
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 440  : 		delete tag;

	call	??_GAllocationUnit@@QAEPAXI@Z
	pop	ebx
	pop	edi
	pop	esi

; 360  : 
; 361  : 	// Free the old memory
; 362  : 	MemoryTracker::Free(memory, DeallocType_Realloc, source_file, source_function, source_line);
; 363  : 
; 364  : 	return new_memory;

	mov	eax, ebp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 32   : 		Flag = 0;

	mov	DWORD PTR _MemoryTrackerCS, 0
	pop	ebp
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 365  : };

	pop	ecx
	ret	0
$LN143@Reallocate:

; 366  : 
; 367  : void MemoryTracker::Free(void* memory, const DeallocType type, const char* source_file, const char* source_function, const int source_line)
; 368  : {
; 369  : 	UNUSED_VARIABLE(source_file);
; 370  : 	UNUSED_VARIABLE(source_function);
; 371  : 	UNUSED_VARIABLE(source_line);
; 372  : 	if (!memory) return; // standard defines free(NULL) as basically a no-op, so do so here.
; 373  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 374  : 
; 375  : 	// If you hit this assert, you tried to deallocate memory that was either not allocated with this allocator 
; 376  : 	// or so badly damaged that it failed the preliminary test
; 377  : 	assert(tag != NULL);

	push	377					; 00000179H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1BI@NNABAJNA@?$AAt?$AAa?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	edi
	add	esp, 12					; 0000000cH

; 360  : 
; 361  : 	// Free the old memory
; 362  : 	MemoryTracker::Free(memory, DeallocType_Realloc, source_file, source_function, source_line);
; 363  : 
; 364  : 	return new_memory;

	mov	eax, ebp
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 365  : };

	pop	ecx
	ret	0
$LN142@Reallocate:

; 333  : 	}
; 334  : 
; 335  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 336  : 
; 337  : 	// If you hit this assert, you tried to reallocate memory that was either not allocated with this allocator 
; 338  : 	// or so badly damaged that it failed the preliminary test
; 339  : 	assert(tag != NULL);

	push	339					; 00000153H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1BI@NNABAJNA@?$AAt?$AAa?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH

; 340  : 
; 341  : 	// We've warned the user about the tag being NULL, let's not actually try to do anything further with the memory
; 342  : 	if (tag == NULL) return NULL;

	xor	eax, eax
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 365  : };

	pop	ecx
	ret	0
?Reallocate@MemoryTracker@@SAPAXPAXIPBD1H@Z ENDP	; MemoryTracker::Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?Free@MemoryTracker@@SAXPAXW4DeallocType@@PBD2H@Z
_TEXT	SEGMENT
_source_file$dead$ = 8					; size = 4
_source_function$dead$ = 12				; size = 4
_source_line$dead$ = 16					; size = 4
?Free@MemoryTracker@@SAXPAXW4DeallocType@@PBD2H@Z PROC	; MemoryTracker::Free, COMDAT
; _memory$ = ecx
; _type$ = edx

; 368  : {

	push	edi
	mov	edi, edx

; 369  : 	UNUSED_VARIABLE(source_file);
; 370  : 	UNUSED_VARIABLE(source_function);
; 371  : 	UNUSED_VARIABLE(source_line);
; 372  : 	if (!memory) return; // standard defines free(NULL) as basically a no-op, so do so here.

	test	ecx, ecx
	je	$LN54@Free

; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation

	cmp	DWORD PTR [ecx-32], -1163005939		; baadf00dH
	push	esi
	jne	$LN62@Free

; 149  : 	return *(AllocationUnit**) actual;

	mov	esi, DWORD PTR [ecx-36]

; 373  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 374  : 
; 375  : 	// If you hit this assert, you tried to deallocate memory that was either not allocated with this allocator 
; 376  : 	// or so badly damaged that it failed the preliminary test
; 377  : 	assert(tag != NULL);

	test	esi, esi
	je	$LN62@Free

; 378  : 
; 379  : 	// We've warned the user about the tag being NULL, let's not actually try to do anything further with the memory
; 380  : 	if (tag == NULL) return;
; 381  : 
; 382  : 	// If you hit this assert, the memory that is about to be deallocated is damaged, but you should have seen
; 383  : 	// an earlier assert in ValidateAllocationUnit
; 384  : 	assert(ValidateAllocationUnit(tag));

	push	ebx
	mov	ecx, esi
	call	?ValidateAllocationUnit@MemoryTracker@@KA_NPAVAllocationUnit@@@Z ; MemoryTracker::ValidateAllocationUnit
	mov	ebx, DWORD PTR __imp___wassert
	test	al, al
	jne	SHORT $LN6@Free
	push	384					; 00000180H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1DI@EPMGAHAB@?$AAV?$AAa?$AAl?$AAi?$AAd?$AAa?$AAt?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CI?$AAt?$AAa?$AAg?$AA?$CJ?$AA?$AA@
	call	ebx
	add	esp, 12					; 0000000cH
$LN6@Free:

; 385  : 
; 386  : 	// If you hit this assert, then this deallocation call was made from a source that isn't setup to use our
; 387  : 	// memory tracking system. Use the callstack to locate the source and include our memory tracker header.
; 388  : 	assert(type != DeallocType_Unknown);

	test	edi, edi
	jne	SHORT $LN7@Free
	push	388					; 00000184H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1DI@CBDDEKGK@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp?$AAe?$AA_?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$AA@
	call	ebx
	add	esp, 12					; 0000000cH
$LN7@Free:

; 389  : 
; 390  : 	// If you hit this assert, you were trying to deallocate RAM that wasn't allocated in a way that's compatible
; 391  : 	// with the deallocation method requested. Simply put, your allocation/deallocation calls are mismatched.
; 392  : 	assert (
; 393  : 		(tag->AllocationType == AllocType_New		&& type == DeallocType_Delete) ||
; 394  : 		(tag->AllocationType == AllocType_VectorNew	&& type == DeallocType_VectorDelete) ||
; 395  : 		(tag->AllocationType == AllocType_Malloc	&& type == DeallocType_Free) ||
; 396  : 		(tag->AllocationType == AllocType_Calloc	&& type == DeallocType_Free) ||
; 397  : 		(tag->AllocationType == AllocType_Realloc	&& type == DeallocType_Free) ||
; 398  : 		(tag->AllocationType == AllocType_Malloc	&& type == DeallocType_Realloc) ||
; 399  : 		(tag->AllocationType == AllocType_Calloc	&& type == DeallocType_Realloc) ||
; 400  : 		(tag->AllocationType == AllocType_Realloc	&& type == DeallocType_Realloc) ||
; 401  : 		(tag->AllocationType == AllocType_Unvalidated) || 
; 402  : 		(type == DeallocType_Unvalidated) 	 
; 403  : 	);

	mov	eax, DWORD PTR [esi+288]
	cmp	eax, 1
	jne	SHORT $LN8@Free
	cmp	edi, 2
	je	SHORT $LN10@Free
$LN8@Free:
	cmp	eax, 2
	jne	SHORT $LN9@Free
	cmp	edi, 3
	je	SHORT $LN10@Free
$LN9@Free:
	cmp	eax, 3
	jne	SHORT $LN11@Free
	cmp	edi, 4
	je	SHORT $LN10@Free
$LN11@Free:
	cmp	eax, 4
	jne	SHORT $LN12@Free
	cmp	edi, eax
	je	SHORT $LN10@Free
$LN12@Free:
	cmp	eax, 5
	jne	SHORT $LN13@Free
	cmp	edi, 4
	je	SHORT $LN10@Free
$LN13@Free:
	cmp	eax, 3
	jne	SHORT $LN14@Free
	cmp	edi, 1
	je	SHORT $LN10@Free
$LN14@Free:
	cmp	eax, 4
	jne	SHORT $LN15@Free
	cmp	edi, 1
	je	SHORT $LN10@Free
$LN15@Free:
	cmp	eax, 5
	jne	SHORT $LN16@Free
	cmp	edi, 1
	je	SHORT $LN10@Free
$LN16@Free:
	cmp	eax, 6
	je	SHORT $LN10@Free
	cmp	edi, 5
	je	SHORT $LN10@Free
	push	403					; 00000193H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1FGC@DNPNIFOO@?$AA?$CI?$AAt?$AAa?$AAg?$AA?9?$AA?$DO?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAT?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAA?$AAl?$AAl?$AAo?$AAc?$AAT?$AAy?$AAp@
	call	ebx
	add	esp, 12					; 0000000cH
$LN10@Free:

; 404  : 
; 405  : 	// If you hit this assert, you requested that we break when this piece of memory came through to be deallocated/reallocated
; 406  : 	assert(!(tag->BreakOnFree && type == DeallocType_Free) || !(tag->BreakOnRealloc && type == DeallocType_Realloc));
; 407  : 	
; 408  : #ifdef LARGE_ALLOCATION_DEBUG_STATS
; 409  : 	if (tag->ReportedSize > (1 << 13)) // big memory
; 410  : 	{
; 411  : 		char buffer[512];
; 412  : 		sprintf(buffer, "%.3f\tfree:\t(%d bytes) <%.3fMiB> %s %s:%d\n", 
; 413  : 			(timeGetTime() - StartTime) / 1000.0f, 
; 414  : 			tag->ReportedSize, 
; 415  : 			FastAllocatorGeneral::Get_Allocator()->GetTotalMemoryUsage() / 1024.f / 1024.0f, 
; 416  : 			tag->SourceFunction, 
; 417  : 			tag->SourceFile, 
; 418  : 			tag->SourceLine);
; 419  : 		OutputDebugStringA(buffer);
; 420  : 	}
; 421  : #endif
; 422  : 	
; 423  : 	// We'll wipe the memory here with our "Released" pattern even though it likely won't do much good.
; 424  : 	WipeMemoryWithPattern(tag, RELEASED_PATTERN);

	push	ecx
	mov	ecx, esi
	call	?WipeMemoryWithPattern@MemoryTracker@@KAXPAVAllocationUnit@@HI@Z ; MemoryTracker::WipeMemoryWithPattern

; 425  : 
; 426  : 	// Nuke the allocation unit tag address
; 427  : 	*(AllocationUnit**)tag->ActualAddress = NULL;

	mov	eax, DWORD PTR [esi+12]
	add	esp, 4
	mov	DWORD PTR [eax], 0

; 428  : 
; 429  : 	// Free the actual memory
; 430  : 	FastAllocatorGeneral::Get_Allocator()->Free(tag->ActualAddress);

	push	DWORD PTR [esi+12]
	mov	ecx, DWORD PTR ___general_allocator
	call	?Free@FastAllocatorGeneral@@QAEXPAX@Z	; FastAllocatorGeneral::Free

; 431  : 
; 432  : 	// Clearing the tracking information insures that if at some later time somebody calls our memory tracker
; 433  : 	// from an unknown source, we don't think it was the last allocation.
; 434  : 	ClearThreadLocalInformation();

	call	?ClearThreadLocalInformation@MemoryTracker@@KAXXZ ; MemoryTracker::ClearThreadLocalInformation
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	mov	eax, OFFSET _MemoryTrackerCS
	pop	ebx
	lock	 bts	 DWORD PTR [eax], 0
	jae	SHORT $LN58@Free
	npad	7
$LL38@Free:
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	lock	 bts	 DWORD PTR [eax], 0
	jb	SHORT $LL38@Free
$LN58@Free:
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 112  : 		if (node->Next) node->Next->Previous = node->Previous;

	mov	edx, DWORD PTR [esi]

; 118  : 		return node;
; 119  : 	};
; 120  : 
; 121  : 	DLNodeBase* GetHead()
; 122  : 	{
; 123  : 		return Head;
; 124  : 	};
; 125  : 
; 126  : 	DLNodeBase* GetTail()
; 127  : 	{
; 128  : 		return Head;
; 129  : 	};
; 130  : 
; 131  : 	void PushHead(DLNodeBase* node_to_insert)
; 132  : 	{
; 133  : 		this->InsertBefore(Head, node_to_insert);
; 134  : 	};
; 135  : 	
; 136  : 	void PushTail(DLNodeBase* node_to_insert)
; 137  : 	{
; 138  : 		this->InsertAfter(Tail, node_to_insert);
; 139  : 	};
; 140  : 
; 141  : 	DLNodeBase* PopHead()
; 142  : 	{
; 143  : 		return this->Head ? this->Remove(Head) : NULL;
; 144  : 	};
; 145  : 
; 146  : 	DLNodeBase* PopTail()
; 147  : 	{
; 148  : 		return this->Tail? this->Remove(Tail) : NULL;
; 149  : 	};
; 150  : };
; 151  : 
; 152  : inline DLNodeBase::DLNodeBase(): Next(NULL), Previous(NULL), List(NULL)
; 153  : {
; 154  : 
; 155  : };
; 156  : 
; 157  : inline DLNodeBase::~DLNodeBase()
; 158  : {
; 159  : 	assert(this->List == NULL); // If list is not NULL, then you forgot to remove this item before deleting it.
; 160  : };
; 161  : 
; 162  : inline DLNodeBase* DLNodeBase::GetNextNode()
; 163  : {
; 164  : 	return this->Next;
; 165  : };
; 166  : 
; 167  : inline DLNodeBase* DLNodeBase::GetPreviousNode()
; 168  : {
; 169  : 	return this->Previous;
; 170  : };
; 171  : 
; 172  : inline DListBase* DLNodeBase::GetList()
; 173  : {
; 174  : 	return this->List;
; 175  : };
; 176  : 
; 177  : inline void DLNodeBase::InsertBefore(DLNodeBase* node)
; 178  : {
; 179  : 	List->InsertBefore(node, this);
; 180  : };
; 181  : 
; 182  : inline void DLNodeBase::InsertAfter(DLNodeBase* node)
; 183  : {
; 184  : 	List->InsertAfter(node, this);
; 185  : };
; 186  : 
; 187  : inline void DLNodeBase::Remove()
; 188  : {
; 189  : 	List->Remove(this);

	mov	ecx, DWORD PTR [esi+8]

; 112  : 		if (node->Next) node->Next->Previous = node->Previous;

	test	edx, edx
	je	SHORT $LN48@Free
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax
$LN48@Free:

; 113  : 		if (node->Previous) node->Previous->Next = node->Next;

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	je	SHORT $LN47@Free
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx], eax
$LN47@Free:

; 114  : 		if (node == this->Head) this->Head = node->Next;

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN46@Free
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN46@Free:

; 115  : 		if (node == this->Tail) this->Tail = node->Previous;

	cmp	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN45@Free
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax
$LN45@Free:
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 440  : 		delete tag;

	push	ecx
	mov	ecx, esi
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 117  : 		node->List = NULL;

	mov	DWORD PTR [esi+8], 0
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 440  : 		delete tag;

	call	??_GAllocationUnit@@QAEPAXI@Z
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 32   : 		Flag = 0;

	mov	DWORD PTR _MemoryTrackerCS, 0
	pop	esi
$LN54@Free:
	pop	edi
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 442  : };

	ret	0
$LN62@Free:
	pop	esi
	pop	edi

; 373  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 374  : 
; 375  : 	// If you hit this assert, you tried to deallocate memory that was either not allocated with this allocator 
; 376  : 	// or so badly damaged that it failed the preliminary test
; 377  : 	assert(tag != NULL);

	mov	DWORD PTR _source_line$dead$[esp-4], 377 ; 00000179H
	mov	DWORD PTR _source_function$dead$[esp-4], OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	mov	DWORD PTR _source_file$dead$[esp-4], OFFSET ??_C@_1BI@NNABAJNA@?$AAt?$AAa?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	jmp	DWORD PTR __imp___wassert
?Free@MemoryTracker@@SAXPAXW4DeallocType@@PBD2H@Z ENDP	; MemoryTracker::Free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?GetAllocationSize@MemoryTracker@@SAIPAX@Z
_TEXT	SEGMENT
?GetAllocationSize@MemoryTracker@@SAIPAX@Z PROC		; MemoryTracker::GetAllocationSize, COMDAT
; _memory$ = ecx

; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation

	cmp	DWORD PTR [ecx-32], -1163005939		; baadf00dH
	push	esi
	jne	SHORT $LN11@GetAllocat

; 149  : 	return *(AllocationUnit**) actual;

	mov	esi, DWORD PTR [ecx-36]

; 446  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 447  : 
; 448  : 	// If you hit this assert, you tried to get the size of memory that was either not allocated with this allocator 
; 449  : 	// or so badly damaged that it failed the preliminary test
; 450  : 	assert(tag != NULL);

	test	esi, esi
	je	SHORT $LN11@GetAllocat

; 454  : 
; 455  : 	// If you hit this assert, the memory that is about to be deallocated is damaged, but you should have seen
; 456  : 	// an earlier assert in ValidateAllocationUnit
; 457  : 	assert(ValidateAllocationUnit(tag));

	mov	ecx, esi
	call	?ValidateAllocationUnit@MemoryTracker@@KA_NPAVAllocationUnit@@@Z ; MemoryTracker::ValidateAllocationUnit
	test	al, al
	jne	SHORT $LN5@GetAllocat
	push	457					; 000001c9H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1DI@EPMGAHAB@?$AAV?$AAa?$AAl?$AAi?$AAd?$AAa?$AAt?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAi?$AAo?$AAn?$AAU?$AAn?$AAi?$AAt?$AA?$CI?$AAt?$AAa?$AAg?$AA?$CJ?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN5@GetAllocat:

; 458  : 
; 459  : 	return tag->ReportedSize;

	mov	eax, DWORD PTR [esi+24]
	pop	esi

; 460  : };

	ret	0
$LN11@GetAllocat:

; 446  : 	AllocationUnit* tag = FindAllocationUnit(memory);
; 447  : 
; 448  : 	// If you hit this assert, you tried to get the size of memory that was either not allocated with this allocator 
; 449  : 	// or so badly damaged that it failed the preliminary test
; 450  : 	assert(tag != NULL);

	push	450					; 000001c2H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1BI@NNABAJNA@?$AAt?$AAa?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH

; 451  : 
; 452  : 	// We've warned the user about the tag being NULL, let's not actually try to do anything further with the memory
; 453  : 	if (tag == NULL) return 0;

	xor	eax, eax
	pop	esi

; 460  : };

	ret	0
?GetAllocationSize@MemoryTracker@@SAIPAX@Z ENDP		; MemoryTracker::GetAllocationSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
;	COMDAT ?strrchr@@YAPADPADH@Z
_TEXT	SEGMENT
?strrchr@@YAPADPADH@Z PROC				; strrchr, COMDAT
; __Str$ = ecx
; __Ch$dead$ = edx

; 222  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

	push	92					; 0000005cH
	push	ecx
	call	DWORD PTR __imp__strrchr
	add	esp, 8
	ret	0
?strrchr@@YAPADPADH@Z ENDP				; strrchr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?GetSize@FastFixedAllocator@@QBEIXZ
_TEXT	SEGMENT
?GetSize@FastFixedAllocator@@QBEIXZ PROC		; FastFixedAllocator::GetSize, COMDAT
; _this$ = ecx

; 87   : 	inline size_t GetSize() const { return ElementSize; }

	mov	eax, DWORD PTR [ecx+16]
	ret	0
?GetSize@FastFixedAllocator@@QBEIXZ ENDP		; FastFixedAllocator::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?Allocate@FastFixedAllocator@@QAEPAXXZ
_TEXT	SEGMENT
?Allocate@FastFixedAllocator@@QAEPAXXZ PROC		; FastFixedAllocator::Allocate, COMDAT
; _this$ = ecx

; 140  : {

	push	edi
	mov	edi, ecx

; 141  : #ifdef FASTALLOC_STATS
; 142  : 	_InterlockedIncrement((long *)&TotalAllocationCount);

	mov	edx, 1
	lea	eax, DWORD PTR [edi+28]
	lock	 xadd	 DWORD PTR [eax], edx

; 143  : 	_InterlockedExchangeAdd((long *)&TotalAllocatedSize, (long)ElementSize);

	mov	edx, DWORD PTR [edi+16]
	lea	eax, DWORD PTR [edi+24]
	lock	 xadd	 DWORD PTR [eax], edx
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 308  : 		return (T*) TSListBase::Pop();

	call	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 147  : 	while (!memory)

	test	eax, eax
	jne	$LN1@Allocate
	push	ebx
	push	ebp
	push	esi
	lea	ebp, DWORD PTR [edi+8]
	lea	esi, DWORD PTR [edi+20]
	npad	1
$LL2@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 28   : 	void* memory = malloc(size);

	push	32768					; 00008000H
	call	DWORD PTR __imp__malloc
	mov	ebx, eax
	add	esp, 4

; 29   : 	// If you hit this assert, you've run out of memory. This is bad.
; 30   : 	assert(memory);

	test	ebx, ebx
	jne	SHORT $LN39@Allocate
	push	30					; 0000001eH
	push	OFFSET ??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 117  : 	Chunk* n = new Chunk;

	jmp	SHORT $LN13@Allocate
$LN39@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 44   : 		Next = 0;

	mov	DWORD PTR [ebx], 0
$LN13@Allocate:

; 303  : 		TSListBase::Push((TSLNode*) item); 

	push	ebx
	mov	ecx, ebp
	call	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 121  : 	_InterlockedExchangeAdd((long *)&TotalHeapSize, sizeof(Chunk));

	mov	eax, 32768				; 00008000H
	lock	 xadd	 DWORD PTR [esi], eax

; 122  : #endif
; 123  : 
; 124  : 	const size_t number_elements = Chunk::size / ElementSize;

	xor	edx, edx
	mov	eax, 32760				; 00007ff8H
	div	DWORD PTR [edi+16]

; 126  : 	for (size_t i = 0; i < number_elements; ++i)

	xor	esi, esi
	mov	ebp, eax
	test	ebp, ebp
	je	SHORT $LN7@Allocate
$LL9@Allocate:

; 127  : 	{
; 128  : 		Link* link = (Link*)(n->Memory + (i * ElementSize) );

	mov	ecx, DWORD PTR [edi+16]
	imul	ecx, esi
	add	ecx, 8
	add	ecx, ebx
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	push	ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 129  : 		link->Next = 0;

	mov	DWORD PTR [ecx], 0
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	mov	ecx, edi
	call	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 126  : 	for (size_t i = 0; i < number_elements; ++i)

	inc	esi
	cmp	esi, ebp
	jb	SHORT $LL9@Allocate
$LN7@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 308  : 		return (T*) TSListBase::Pop();

	mov	ecx, edi
	call	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 147  : 	while (!memory)

	lea	ebp, DWORD PTR [edi+8]
	lea	esi, DWORD PTR [edi+20]
	test	eax, eax
	je	$LL2@Allocate
	pop	esi
	pop	ebp
	pop	ebx
$LN1@Allocate:
	pop	edi

; 148  : 	{
; 149  : 		Grow();
; 150  : 		memory = FreeList.Pop();
; 151  : 		YieldThread();
; 152  : 	}
; 153  : 	return memory;
; 154  : };

	ret	0
?Allocate@FastFixedAllocator@@QAEPAXXZ ENDP		; FastFixedAllocator::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?Free@FastFixedAllocator@@QAEXPAX@Z
_TEXT	SEGMENT
_memory$ = 8						; size = 4
?Free@FastFixedAllocator@@QAEXPAX@Z PROC		; FastFixedAllocator::Free, COMDAT
; _this$ = ecx

; 158  : 	assert(memory); // If you hit this assert, you tried to free NULL. NULL doesn't want to be free ;)

	cmp	DWORD PTR _memory$[esp-4], 0
	push	esi
	mov	esi, ecx
	jne	SHORT $LN3@Free
	push	158					; 0000009eH
	push	OFFSET ??_C@_1HO@PBNFMELI@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN3@Free:

; 159  : #ifdef FASTALLOC_STATS
; 160  : 	_InterlockedDecrement((long*)&TotalAllocationCount);

	lea	eax, DWORD PTR [esi+28]
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx

; 161  : 	_InterlockedExchangeAdd((long*)&TotalAllocatedSize, -(long)ElementSize);

	mov	ecx, DWORD PTR [esi+16]
	neg	ecx
	lea	eax, DWORD PTR [esi+24]
	lock	 xadd	 DWORD PTR [eax], ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	push	DWORD PTR _memory$[esp]
	mov	ecx, esi
	call	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
	pop	esi
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 165  : };

	ret	4
?Free@FastFixedAllocator@@QAEXPAX@Z ENDP		; FastFixedAllocator::Free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?GetAllocatorIndex@FastAllocatorGeneral@@IBEKI@Z
_TEXT	SEGMENT
_result$ = 8						; size = 4
_input$ = 8						; size = 4
?GetAllocatorIndex@FastAllocatorGeneral@@IBEKI@Z PROC	; FastAllocatorGeneral::GetAllocatorIndex, COMDAT
; _this$dead$ = ecx

; 221  : 	unsigned long result;
; 222  : 	ASSUME((input & 0xFFFFFFFF00000000) == 0); // assume we are only doing allocation below 32 bits, please?

	xor	eax, eax
	or	eax, eax
	je	SHORT $LN3@GetAllocat
	push	222					; 000000deH
	push	OFFSET ??_C@_1HO@PBNFMELI@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1EE@PCKHKONG@?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN3@GetAllocat:

; 223  : 	_BitScanReverse(&result, (int32)(input - 1) / (MIN_ALLOC_SIZE / 2) | 1);

	mov	eax, DWORD PTR _input$[esp-4]
	dec	eax
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	or	eax, 1
	bsr	eax, eax
	mov	DWORD PTR _result$[esp-4], eax

; 224  : 	return result;
; 225  : };

	ret	4
?GetAllocatorIndex@FastAllocatorGeneral@@IBEKI@Z ENDP	; FastAllocatorGeneral::GetAllocatorIndex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?Allocate@FastAllocatorGeneral@@QAEPAXI@Z
_TEXT	SEGMENT
_result$1 = 8						; size = 4
_size$ = 8						; size = 4
?Allocate@FastAllocatorGeneral@@QAEPAXI@Z PROC		; FastAllocatorGeneral::Allocate, COMDAT
; _this$ = ecx

; 228  : {

	push	ebx
	push	ebp
	push	edi

; 229  : 	void* memory = 0;
; 230  : 
; 231  : 	// let's actually allocate n+4 bytes so we can store the
; 232  : 	// number of bytes we allocate and return a pointer to the
; 233  : 	// rest back to the user.
; 234  : 	size += sizeof(size_t);

	mov	edi, DWORD PTR _size$[esp+8]
	add	edi, 4
	mov	ebp, ecx

; 235  : 
; 236  : 	size_t index = 0;
; 237  : 
; 238  : 	if (size < MAX_ALLOC_SIZE)

	cmp	edi, 8192				; 00002000H
	jae	SHORT $LN2@Allocate

; 222  : 	ASSUME((input & 0xFFFFFFFF00000000) == 0); // assume we are only doing allocation below 32 bits, please?

	xor	eax, eax
	or	eax, eax
	je	SHORT $LN7@Allocate
	push	222					; 000000deH
	push	OFFSET ??_C@_1HO@PBNFMELI@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1EE@PCKHKONG@?$AA?$CI?$AAi?$AAn?$AAp?$AAu?$AAt?$AA?5?$AA?$CG?$AA?5?$AA0?$AAx?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AAF?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN7@Allocate:

; 223  : 	_BitScanReverse(&result, (int32)(input - 1) / (MIN_ALLOC_SIZE / 2) | 1);

	lea	eax, DWORD PTR [edi-1]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	or	eax, 1
	bsr	eax, eax
	push	esi

; 239  : 	{
; 240  : 		index = GetAllocatorIndex(size);

	mov	edi, eax

; 241  : 		memory = allocators[index].Allocate();

	mov	esi, edi
	shl	esi, 5
	add	esi, ebp
	mov	ecx, esi

; 223  : 	_BitScanReverse(&result, (int32)(input - 1) / (MIN_ALLOC_SIZE / 2) | 1);

	mov	DWORD PTR _result$1[esp+12], eax

; 241  : 		memory = allocators[index].Allocate();

	call	?Allocate@FastFixedAllocator@@QAEPAXXZ	; FastFixedAllocator::Allocate

; 242  : #ifdef FASTALLOC_STATS
; 243  : 		_InterlockedExchangeAdd((long*)&ActualMemoryUsage, (long)allocators[index].GetSize());

	mov	edx, DWORD PTR [esi+16]
	mov	ebx, eax
	lea	ecx, DWORD PTR [ebp+352]
	lock	 xadd	 DWORD PTR [ecx], edx
	pop	esi

; 258  : 	*((size_t*)memory) = index; // save the augmented size so we can use it later to liberate the memory and not royally screw things up

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	ebp

; 259  : 	return ((size_t*)memory) + 1; // and don't tell the user about the augmented size cuz we are evil and all that

	lea	eax, DWORD PTR [ebx+4]
	pop	ebx

; 260  : };

	ret	4
$LN2@Allocate:

; 244  : #endif
; 245  : 	}
; 246  : 	else
; 247  : 	{
; 248  : #ifdef FASTALLOC_STATS
; 249  : 		_InterlockedExchangeAdd((long*)&ActualMemoryUsage, size);

	mov	ecx, edi
	lea	eax, DWORD PTR [ebp+352]
	lock	 xadd	 DWORD PTR [eax], ecx

; 250  : 		_InterlockedExchangeAdd((long*)&ExternalMemoryUsage, size);

	mov	ecx, edi
	lea	eax, DWORD PTR [ebp+356]
	lock	 xadd	 DWORD PTR [eax], ecx

; 251  : 		_InterlockedIncrement((long*)&ExternalMemoryCount);

	lea	eax, DWORD PTR [ebp+360]
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax], ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 28   : 	void* memory = malloc(size);

	push	edi
	call	DWORD PTR __imp__malloc
	mov	ebx, eax
	add	esp, 4

; 29   : 	// If you hit this assert, you've run out of memory. This is bad.
; 30   : 	assert(memory);

	test	ebx, ebx
	jne	SHORT $LN14@Allocate
	push	30					; 0000001eH
	push	OFFSET ??_C@_1CE@CODLPNHK@?$AAF?$AAa?$AAs?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAo?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN14@Allocate:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 258  : 	*((size_t*)memory) = index; // save the augmented size so we can use it later to liberate the memory and not royally screw things up

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	ebp

; 259  : 	return ((size_t*)memory) + 1; // and don't tell the user about the augmented size cuz we are evil and all that

	lea	eax, DWORD PTR [ebx+4]
	pop	ebx

; 260  : };

	ret	4
?Allocate@FastAllocatorGeneral@@QAEPAXI@Z ENDP		; FastAllocatorGeneral::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?Free@FastAllocatorGeneral@@QAEXPAX@Z
_TEXT	SEGMENT
__memory$ = 8						; size = 4
?Free@FastAllocatorGeneral@@QAEXPAX@Z PROC		; FastAllocatorGeneral::Free, COMDAT
; _this$ = ecx

; 264  : 	if (_memory)

	mov	eax, DWORD PTR __memory$[esp-4]
	push	edi
	mov	edi, ecx
	test	eax, eax
	je	SHORT $LN15@Free

; 265  : 	{
; 266  : 		void* memory = ((size_t*)_memory) - 1; // Retrieve the real memory
; 267  : 		
; 268  : 		size_t index = *((size_t*)memory);

	mov	edx, DWORD PTR [eax-4]
	push	ebx
	lea	ebx, DWORD PTR [eax-4]

; 269  : 
; 270  : 		if (index < NUM_ALLOCATORS)
; 271  : 		{
; 272  : #ifdef FASTALLOC_STATS
; 273  : 			_InterlockedExchangeAdd((long*)&ActualMemoryUsage, -(long)allocators[index].GetSize());

	lea	eax, DWORD PTR [edi+352]
	cmp	edx, 11					; 0000000bH
	jae	SHORT $LN2@Free
	shl	edx, 5
	push	esi
	mov	ecx, DWORD PTR [edx+edi+16]

; 87   : 	inline size_t GetSize() const { return ElementSize; }

	lea	esi, DWORD PTR [edx+edi]

; 269  : 
; 270  : 		if (index < NUM_ALLOCATORS)
; 271  : 		{
; 272  : #ifdef FASTALLOC_STATS
; 273  : 			_InterlockedExchangeAdd((long*)&ActualMemoryUsage, -(long)allocators[index].GetSize());

	neg	ecx
	lock	 xadd	 DWORD PTR [eax], ecx

; 88   : 
; 89   : 	DECLSPEC_RESTRICT void* Allocate();
; 90   : 	void Free(void* memory);
; 91   : };
; 92   : 
; 93   : inline FastFixedAllocator::FastFixedAllocator(size_t element_size): 
; 94   : ElementSize(1), 
; 95   : Chunks(), 
; 96   : FreeList()
; 97   : #ifdef FASTALLOC_STATS
; 98   : ,
; 99   : TotalHeapSize(0),
; 100  : TotalAllocatedSize(0),
; 101  : TotalAllocationCount(0)
; 102  : #endif
; 103  : {
; 104  : 	Init(element_size);
; 105  : };
; 106  : 
; 107  : inline FastFixedAllocator::~FastFixedAllocator() // *not* thread safe
; 108  : {
; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())
; 110  : 	{
; 111  : 		delete n;
; 112  : 	};
; 113  : };
; 114  : 
; 115  : inline void FastFixedAllocator::Grow()
; 116  : {
; 117  : 	Chunk* n = new Chunk;
; 118  : 	Chunks.Push(n);
; 119  : 
; 120  : #ifdef FASTALLOC_STATS
; 121  : 	_InterlockedExchangeAdd((long *)&TotalHeapSize, sizeof(Chunk));
; 122  : #endif
; 123  : 
; 124  : 	const size_t number_elements = Chunk::size / ElementSize;
; 125  : 
; 126  : 	for (size_t i = 0; i < number_elements; ++i)
; 127  : 	{
; 128  : 		Link* link = (Link*)(n->Memory + (i * ElementSize) );
; 129  : 		link->Next = 0;
; 130  : 		FreeList.Push(link);
; 131  : 	};
; 132  : };
; 133  : 
; 134  : inline void FastFixedAllocator::Init(size_t element_size)
; 135  : {
; 136  : 	this->ElementSize = element_size < sizeof(Link) ? sizeof (Link) : element_size;
; 137  : };
; 138  : 
; 139  : DECLSPEC_RESTRICT inline void* FastFixedAllocator::Allocate()
; 140  : {
; 141  : #ifdef FASTALLOC_STATS
; 142  : 	_InterlockedIncrement((long *)&TotalAllocationCount);
; 143  : 	_InterlockedExchangeAdd((long *)&TotalAllocatedSize, (long)ElementSize);
; 144  : #endif
; 145  : 
; 146  : 	void* memory = FreeList.Pop();
; 147  : 	while (!memory)
; 148  : 	{
; 149  : 		Grow();
; 150  : 		memory = FreeList.Pop();
; 151  : 		YieldThread();
; 152  : 	}
; 153  : 	return memory;
; 154  : };
; 155  : 
; 156  : inline void FastFixedAllocator::Free(void* memory)
; 157  : {
; 158  : 	assert(memory); // If you hit this assert, you tried to free NULL. NULL doesn't want to be free ;)
; 159  : #ifdef FASTALLOC_STATS
; 160  : 	_InterlockedDecrement((long*)&TotalAllocationCount);

	lea	eax, DWORD PTR [esi+28]
	or	edx, -1
	lock	 xadd	 DWORD PTR [eax], edx

; 161  : 	_InterlockedExchangeAdd((long*)&TotalAllocatedSize, -(long)ElementSize);

	mov	edx, DWORD PTR [esi+16]
	neg	edx
	lea	eax, DWORD PTR [esi+24]
	lock	 xadd	 DWORD PTR [eax], edx
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	push	ebx
	mov	ecx, esi
	call	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
	pop	esi
	pop	ebx
	pop	edi
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 288  : };

	ret	4
$LN2@Free:

; 274  : #endif
; 275  : 			allocators[index].Free(memory);
; 276  : 		}
; 277  : 		else
; 278  : 		{
; 279  : #ifdef FASTALLOC_STATS
; 280  : 			_InterlockedExchangeAdd((long*)&ActualMemoryUsage, -(long)index);

	neg	edx
	mov	ecx, edx
	lock	 xadd	 DWORD PTR [eax], ecx

; 281  : 			_InterlockedExchangeAdd((long*)&ExternalMemoryUsage, -(long)index);

	lea	eax, DWORD PTR [edi+356]
	lock	 xadd	 DWORD PTR [eax], edx

; 282  : 			_InterlockedDecrement((long*)&ExternalMemoryCount);

	lea	eax, DWORD PTR [edi+360]
	or	ecx, -1
	lock	 xadd	 DWORD PTR [eax], ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 36   : 	free(memory);

	push	ebx
	call	DWORD PTR __imp__free
	add	esp, 4
	pop	ebx
$LN15@Free:
	pop	edi
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 288  : };

	ret	4
?Free@FastAllocatorGeneral@@QAEXPAX@Z ENDP		; FastAllocatorGeneral::Free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??0DListBase@@QAE@XZ
_TEXT	SEGMENT
??0DListBase@@QAE@XZ PROC				; DListBase::DListBase, COMDAT
; _this$dead$ = ecx

; 41   : 	{

	mov	DWORD PTR _Tags, 0
	mov	DWORD PTR _Tags+4, 0

; 42   : 		
; 43   : 	};

	mov	eax, OFFSET _Tags
	ret	0
??0DListBase@@QAE@XZ ENDP				; DListBase::DListBase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??1DListBase@@QAE@XZ
_TEXT	SEGMENT
??1DListBase@@QAE@XZ PROC				; DListBase::~DListBase, COMDAT
; _this$dead$ = ecx

; 47   : 		assert(this->Head == NULL); // If head is not NULL, then this list is not empty

	cmp	DWORD PTR _Tags, 0
	je	SHORT $LN3@DListBase
	push	47					; 0000002fH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@HEKIGBGD@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN3@DListBase:

; 48   : 		assert(this->Tail == NULL); // If tail is not NULL, then etc

	cmp	DWORD PTR _Tags+4, 0
	je	SHORT $LN4@DListBase
	push	48					; 00000030H
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@OMNJOPJE@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN4@DListBase:

; 49   : 	};

	ret	0
??1DListBase@@QAE@XZ ENDP				; DListBase::~DListBase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ?InsertAfter@DListBase@@QAEXPAVDLNodeBase@@0@Z
_TEXT	SEGMENT
_node$ = 8						; size = 4
_node_to_insert$ = 12					; size = 4
?InsertAfter@DListBase@@QAEXPAVDLNodeBase@@0@Z PROC	; DListBase::InsertAfter, COMDAT
; _this$dead$ = ecx

; 80   : 	{

	push	ebx
	push	esi

; 81   : 		assert(node_to_insert->List == NULL); // If list is not NULL, then node_to_insert is already part of a list

	mov	esi, DWORD PTR _node_to_insert$[esp+4]
	push	edi
	cmp	DWORD PTR [esi+8], 0
	mov	edi, DWORD PTR __imp___wassert
	je	SHORT $LN7@InsertAfte
	push	81					; 00000051H
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1DK@FJPHHHDI@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	edi
	add	esp, 12					; 0000000cH
$LN7@InsertAfte:

; 82   : 		assert(node_to_insert->Next == NULL); // If next is not NULL, then etc

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN8@InsertAfte
	push	82					; 00000052H
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1DK@HHINBFPG@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAN?$AAe?$AAx?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	edi
	add	esp, 12					; 0000000cH
$LN8@InsertAfte:

; 83   : 		assert(node_to_insert->Previous == NULL); // If previous is not NULL, then etc

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN9@InsertAfte
	push	83					; 00000053H
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1EC@OCKBJEMP@?$AAn?$AAo?$AAd?$AAe?$AA_?$AAt?$AAo?$AA_?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?9?$AA?$DO?$AAP?$AAr?$AAe?$AAv?$AAi?$AAo?$AAu?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
	call	edi
	add	esp, 12					; 0000000cH
$LN9@InsertAfte:

; 84   : 
; 85   : 		node_to_insert->List = this;
; 86   : 		if (node)

	mov	ebx, DWORD PTR _node$[esp+8]
	mov	DWORD PTR [esi+8], OFFSET _Tags
	test	ebx, ebx
	je	SHORT $LN4@InsertAfte

; 87   : 		{
; 88   : 			assert(this->Head != NULL);

	cmp	DWORD PTR _Tags, 0
	jne	SHORT $LN10@InsertAfte
	push	88					; 00000058H
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@DFKNIMDF@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	edi
	add	esp, 12					; 0000000cH
$LN10@InsertAfte:

; 89   : 			assert(this->Tail != NULL);

	cmp	DWORD PTR _Tags+4, 0
	jne	SHORT $LN11@InsertAfte
	push	89					; 00000059H
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@KNNMACMC@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	edi
	add	esp, 12					; 0000000cH
$LN11@InsertAfte:

; 90   : 			node_to_insert->Previous = node;

	mov	DWORD PTR [esi+4], ebx

; 91   : 			if (node->Next)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN3@InsertAfte

; 92   : 			{
; 93   : 				node->Next->Previous = node_to_insert;

	mov	DWORD PTR [eax+4], esi
$LN3@InsertAfte:

; 94   : 			};
; 95   : 			node->Next = node_to_insert;

	mov	DWORD PTR [ebx], esi

; 96   : 			if (this->Tail == node)

	cmp	DWORD PTR _Tags+4, ebx
	jne	SHORT $LN1@InsertAfte

; 97   : 			{
; 98   : 				this->Tail = node_to_insert;
; 99   : 			};
; 100  : 		} 
; 101  : 		else
; 102  : 		{
; 103  : 			// empty list
; 104  : 			this->Tail = this->Head = node_to_insert;

	pop	edi
	mov	DWORD PTR _Tags+4, esi
	pop	esi
	pop	ebx

; 105  : 		};
; 106  : 	};

	ret	8
$LN4@InsertAfte:

; 97   : 			{
; 98   : 				this->Tail = node_to_insert;
; 99   : 			};
; 100  : 		} 
; 101  : 		else
; 102  : 		{
; 103  : 			// empty list
; 104  : 			this->Tail = this->Head = node_to_insert;

	mov	DWORD PTR _Tags, esi
	mov	DWORD PTR _Tags+4, esi
$LN1@InsertAfte:

; 105  : 		};
; 106  : 	};

	pop	edi
	pop	esi
	pop	ebx
	ret	8
?InsertAfter@DListBase@@QAEXPAVDLNodeBase@@0@Z ENDP	; DListBase::InsertAfter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ?Remove@DListBase@@QAEPAVDLNodeBase@@PAV2@@Z
_TEXT	SEGMENT
_node$ = 8						; size = 4
?Remove@DListBase@@QAEPAVDLNodeBase@@PAV2@@Z PROC	; DListBase::Remove, COMDAT
; _this$ = ecx

; 109  : 	{

	push	esi

; 110  : 		assert (node->List == this); // If the node's list is not this one, you are trying to remove this item from the wrong list

	mov	esi, DWORD PTR _node$[esp]
	push	edi
	mov	edi, ecx
	cmp	DWORD PTR [esi+8], edi
	je	SHORT $LN7@Remove
	push	110					; 0000006eH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@JPJLGBEJ@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN7@Remove:

; 111  : 
; 112  : 		if (node->Next) node->Next->Previous = node->Previous;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@Remove
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax
$LN4@Remove:

; 113  : 		if (node->Previous) node->Previous->Next = node->Next;

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN3@Remove
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN3@Remove:

; 114  : 		if (node == this->Head) this->Head = node->Next;

	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LN2@Remove
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
$LN2@Remove:

; 118  : 		return node;

	mov	eax, esi
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN8@Remove

; 115  : 		if (node == this->Tail) this->Tail = node->Previous;

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], ecx
$LN8@Remove:

; 116  : 
; 117  : 		node->List = NULL;

	pop	edi
	mov	DWORD PTR [esi+8], 0
	pop	esi

; 119  : 	};

	ret	4
?Remove@DListBase@@QAEPAVDLNodeBase@@PAV2@@Z ENDP	; DListBase::Remove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ?PushTail@DListBase@@QAEXPAVDLNodeBase@@@Z
_TEXT	SEGMENT
_node_to_insert$ = 8					; size = 4
?PushTail@DListBase@@QAEXPAVDLNodeBase@@@Z PROC		; DListBase::PushTail, COMDAT
; _this$dead$ = ecx

; 138  : 		this->InsertAfter(Tail, node_to_insert);

	push	DWORD PTR _node_to_insert$[esp-4]
	push	DWORD PTR _Tags+4
	call	?InsertAfter@DListBase@@QAEXPAVDLNodeBase@@0@Z ; DListBase::InsertAfter

; 139  : 	};

	ret	4
?PushTail@DListBase@@QAEXPAVDLNodeBase@@@Z ENDP		; DListBase::PushTail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ?PopHead@DListBase@@QAEPAVDLNodeBase@@XZ
_TEXT	SEGMENT
?PopHead@DListBase@@QAEPAVDLNodeBase@@XZ PROC		; DListBase::PopHead, COMDAT
; _this$dead$ = ecx

; 143  : 		return this->Head ? this->Remove(Head) : NULL;

	mov	eax, DWORD PTR _Tags
	test	eax, eax
	je	SHORT $LN3@PopHead

; 110  : 		assert (node->List == this); // If the node's list is not this one, you are trying to remove this item from the wrong list

	cmp	DWORD PTR [eax+8], OFFSET _Tags
	push	esi
	push	edi
	lea	edi, DWORD PTR [eax+8]

; 143  : 		return this->Head ? this->Remove(Head) : NULL;

	mov	esi, eax

; 110  : 		assert (node->List == this); // If the node's list is not this one, you are trying to remove this item from the wrong list

	je	SHORT $LN11@PopHead
	push	110					; 0000006eH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@JPJLGBEJ@?$AAn?$AAo?$AAd?$AAe?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?$AA@
	call	DWORD PTR __imp___wassert
	mov	eax, DWORD PTR _Tags
	add	esp, 12					; 0000000cH
$LN11@PopHead:

; 111  : 
; 112  : 		if (node->Next) node->Next->Previous = node->Previous;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN8@PopHead
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _Tags
$LN8@PopHead:

; 113  : 		if (node->Previous) node->Previous->Next = node->Next;

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN7@PopHead
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _Tags
$LN7@PopHead:

; 114  : 		if (node == this->Head) this->Head = node->Next;

	cmp	esi, eax
	jne	SHORT $LN6@PopHead
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _Tags, eax
$LN6@PopHead:

; 115  : 		if (node == this->Tail) this->Tail = node->Previous;

	cmp	esi, DWORD PTR _Tags+4
	jne	SHORT $LN5@PopHead
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _Tags+4, ecx
$LN5@PopHead:

; 116  : 
; 117  : 		node->List = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi

; 143  : 		return this->Head ? this->Remove(Head) : NULL;

	mov	eax, esi
	pop	esi

; 144  : 	};

	ret	0
$LN3@PopHead:

; 143  : 		return this->Head ? this->Remove(Head) : NULL;

	xor	eax, eax

; 144  : 	};

	ret	0
?PopHead@DListBase@@QAEPAVDLNodeBase@@XZ ENDP		; DListBase::PopHead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??0DLNodeBase@@QAE@XZ
_TEXT	SEGMENT
??0DLNodeBase@@QAE@XZ PROC				; DLNodeBase::DLNodeBase, COMDAT
; _this$ = ecx

; 153  : {

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0

; 154  : 
; 155  : };

	mov	eax, ecx
	ret	0
??0DLNodeBase@@QAE@XZ ENDP				; DLNodeBase::DLNodeBase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??1DLNodeBase@@QAE@XZ
_TEXT	SEGMENT
??1DLNodeBase@@QAE@XZ PROC				; DLNodeBase::~DLNodeBase, COMDAT
; _this$ = ecx

; 159  : 	assert(this->List == NULL); // If list is not NULL, then you forgot to remove this item before deleting it.

	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN3@DLNodeBase
	push	159					; 0000009fH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@ICFGHNLI@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN3@DLNodeBase:

; 160  : };

	ret	0
??1DLNodeBase@@QAE@XZ ENDP				; DLNodeBase::~DLNodeBase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ?Remove@DLNodeBase@@QAEXXZ
_TEXT	SEGMENT
?Remove@DLNodeBase@@QAEXXZ PROC				; DLNodeBase::Remove, COMDAT
; _this$ = ecx

; 189  : 	List->Remove(this);

	mov	edx, DWORD PTR [ecx+8]
	push	esi

; 112  : 		if (node->Next) node->Next->Previous = node->Previous;

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN6@Remove
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
$LN6@Remove:

; 113  : 		if (node->Previous) node->Previous->Next = node->Next;

	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN5@Remove
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax
$LN5@Remove:
	pop	esi

; 114  : 		if (node == this->Head) this->Head = node->Next;

	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN4@Remove
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
$LN4@Remove:

; 115  : 		if (node == this->Tail) this->Tail = node->Previous;

	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN10@Remove
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN10@Remove:

; 116  : 
; 117  : 		node->List = NULL;

	mov	DWORD PTR [ecx+8], 0

; 190  : };

	ret	0
?Remove@DLNodeBase@@QAEXXZ ENDP				; DLNodeBase::Remove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
;	COMDAT ??0AllocationUnit@@QAE@XZ
_TEXT	SEGMENT
??0AllocationUnit@@QAE@XZ PROC				; AllocationUnit::AllocationUnit, COMDAT
; _this$ = ecx

; 70   : 	{

	push	esi
	mov	esi, ecx
	push	128					; 00000080H
	lea	eax, DWORD PTR [esi+28]
	push	0
	push	eax
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 153  : {

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h

; 70   : 	{

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	call	_memset
	push	128					; 00000080H
	lea	eax, DWORD PTR [esi+156]
	push	0
	push	eax
	call	_memset
	mov	DWORD PTR [esi+284], -1
	mov	DWORD PTR [esi+288], 0
	mov	DWORD PTR [esi+292], -1
	xorps	xmm0, xmm0
	movq	QWORD PTR [esi+296], xmm0
	movq	QWORD PTR [esi+304], xmm0
	movq	QWORD PTR [esi+312], xmm0
	add	esp, 24					; 00000018H
	movq	QWORD PTR [esi+320], xmm0
	mov	WORD PTR [esi+328], 0

; 71   : 
; 72   : 	};

	mov	eax, esi
	pop	esi
	ret	0
??0AllocationUnit@@QAE@XZ ENDP				; AllocationUnit::AllocationUnit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??0?$DLNode@VAllocationUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$DLNode@VAllocationUnit@@@@QAE@XZ PROC		; DLNode<AllocationUnit>::DLNode<AllocationUnit>, COMDAT
; _this$ = ecx

; 153  : {

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	eax, ecx
	ret	0
??0?$DLNode@VAllocationUnit@@@@QAE@XZ ENDP		; DLNode<AllocationUnit>::DLNode<AllocationUnit>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??1?$DLNode@VAllocationUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$DLNode@VAllocationUnit@@@@QAE@XZ PROC		; DLNode<AllocationUnit>::~DLNode<AllocationUnit>, COMDAT
; _this$ = ecx

; 159  : 	assert(this->List == NULL); // If list is not NULL, then you forgot to remove this item before deleting it.

	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN5@DLNode
	push	159					; 0000009fH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@ICFGHNLI@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN5@DLNode:
	ret	0
??1?$DLNode@VAllocationUnit@@@@QAE@XZ ENDP		; DLNode<AllocationUnit>::~DLNode<AllocationUnit>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
;	COMDAT ?CalculateActualAddress@MemoryTracker@@KAPAXPAX@Z
_TEXT	SEGMENT
?CalculateActualAddress@MemoryTracker@@KAPAXPAX@Z PROC	; MemoryTracker::CalculateActualAddress, COMDAT
; _reported_address$ = ecx

; 125  : 		// memory start - sentinel size - pointer size 
; 126  : 		return (char*)reported_address - (SENTINEL_SIZE * sizeof(int32)) - sizeof(AllocationUnit*);

	lea	eax, DWORD PTR [ecx-36]

; 127  : 	};

	ret	0
?CalculateActualAddress@MemoryTracker@@KAPAXPAX@Z ENDP	; MemoryTracker::CalculateActualAddress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
;	COMDAT ?CalculateReportedAddress@MemoryTracker@@KAPAXPAX@Z
_TEXT	SEGMENT
?CalculateReportedAddress@MemoryTracker@@KAPAXPAX@Z PROC ; MemoryTracker::CalculateReportedAddress, COMDAT
; _actual_address$ = ecx

; 131  : 		// actual + pointer size + sentinel size 
; 132  : 		return (char*)actual_address + sizeof(AllocationUnit*) + (SENTINEL_SIZE * sizeof(int32));

	lea	eax, DWORD PTR [ecx+36]

; 133  : 	};

	ret	0
?CalculateReportedAddress@MemoryTracker@@KAPAXPAX@Z ENDP ; MemoryTracker::CalculateReportedAddress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
;	COMDAT ?CalculatePrefixSentinelStartAddress@MemoryTracker@@KAPAXPAVAllocationUnit@@@Z
_TEXT	SEGMENT
?CalculatePrefixSentinelStartAddress@MemoryTracker@@KAPAXPAVAllocationUnit@@@Z PROC ; MemoryTracker::CalculatePrefixSentinelStartAddress, COMDAT
; _unit$ = ecx

; 137  : 		// actual + pointer size
; 138  : 		return (char*)unit->ActualAddress + sizeof(AllocationUnit*);

	mov	eax, DWORD PTR [ecx+12]
	add	eax, 4

; 139  : 	};

	ret	0
?CalculatePrefixSentinelStartAddress@MemoryTracker@@KAPAXPAVAllocationUnit@@@Z ENDP ; MemoryTracker::CalculatePrefixSentinelStartAddress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
;	COMDAT ?CalculatePostfixSentinelStartAddress@MemoryTracker@@KAPAXPAVAllocationUnit@@@Z
_TEXT	SEGMENT
?CalculatePostfixSentinelStartAddress@MemoryTracker@@KAPAXPAVAllocationUnit@@@Z PROC ; MemoryTracker::CalculatePostfixSentinelStartAddress, COMDAT
; _unit$ = ecx

; 143  : 		// memory start + memory size
; 144  : 		return (char*)unit->ReportedAddress + unit->ReportedSize;

	mov	eax, DWORD PTR [ecx+24]
	add	eax, DWORD PTR [ecx+20]

; 145  : 	};

	ret	0
?CalculatePostfixSentinelStartAddress@MemoryTracker@@KAPAXPAVAllocationUnit@@@Z ENDP ; MemoryTracker::CalculatePostfixSentinelStartAddress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
;	COMDAT ?ClearThreadLocalInformation@MemoryTracker@@KAXXZ
_TEXT	SEGMENT
?ClearThreadLocalInformation@MemoryTracker@@KAXXZ PROC	; MemoryTracker::ClearThreadLocalInformation, COMDAT

; 148  : 	{

	push	edi
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 219  : 	void* tls_mem = TlsGetValue(TLSIndex);

	push	DWORD PTR ?TLSIndex@@3KA		; TLSIndex
	call	DWORD PTR __imp__TlsGetValue@4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	-1
	push	OFFSET ??_C@_0P@OLMEFAAF@?$CIUnknown?5File?$CJ?$AA@
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 225  : 	MemoryTrackerThreadLocalInformation* info = GetThreadLocalInformation();

	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	128					; 00000080H
	push	edi
	call	DWORD PTR __imp__strncpy_s
	push	-1
	push	OFFSET ??_C@_0BD@OJFFOEJL@?$CIUnknown?5Function?$CJ?$AA@
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 227  : 	strncpy_s(info->CurrentSourceFunction, source_function ? source_function : "(Unknown Function)", _TRUNCATE);

	lea	eax, DWORD PTR [edi+128]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	128					; 00000080H
	push	eax
	call	DWORD PTR __imp__strncpy_s
	add	esp, 32					; 00000020H
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 228  : 	info->CurrentSourceLine = source_line;

	mov	DWORD PTR [edi+256], -1
	pop	edi
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h

; 150  : 	};

	ret	0
?ClearThreadLocalInformation@MemoryTracker@@KAXXZ ENDP	; MemoryTracker::ClearThreadLocalInformation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
;	COMDAT ??0FastCriticalSection@@QAE@XZ
_TEXT	SEGMENT
??0FastCriticalSection@@QAE@XZ PROC			; FastCriticalSection::FastCriticalSection, COMDAT
; _this$dead$ = ecx

; 20   : 	inline FastCriticalSection(): Flag(0) {};

	mov	DWORD PTR _MemoryTrackerCS, 0
	mov	eax, OFFSET _MemoryTrackerCS
	ret	0
??0FastCriticalSection@@QAE@XZ ENDP			; FastCriticalSection::FastCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
;	COMDAT ?Enter@FastCriticalSection@@QAEXXZ
_TEXT	SEGMENT
?Enter@FastCriticalSection@@QAEXXZ PROC			; FastCriticalSection::Enter, COMDAT
; _this$ = ecx

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	lock	 bts	 DWORD PTR [ecx], 0
	jae	SHORT $LN10@Enter
$LL3@Enter:
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	lock	 bts	 DWORD PTR [ecx], 0
	jb	SHORT $LL3@Enter
$LN10@Enter:

; 27   : 			YieldThread();
; 28   : 		};
; 29   : 	};

	ret	0
?Enter@FastCriticalSection@@QAEXXZ ENDP			; FastCriticalSection::Enter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
;	COMDAT ?Leave@FastCriticalSection@@QAEXXZ
_TEXT	SEGMENT
?Leave@FastCriticalSection@@QAEXXZ PROC			; FastCriticalSection::Leave, COMDAT
; _this$ = ecx

; 32   : 		Flag = 0;

	mov	DWORD PTR [ecx], 0

; 33   : 	};

	ret	0
?Leave@FastCriticalSection@@QAEXXZ ENDP			; FastCriticalSection::Leave
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
;	COMDAT ??0Lock@FastCriticalSection@@QAE@AAV1@@Z
_TEXT	SEGMENT
__cs$dead$ = 8						; size = 4
??0Lock@FastCriticalSection@@QAE@AAV1@@Z PROC		; FastCriticalSection::Lock::Lock, COMDAT
; _this$ = ecx

; 45   : 		{

	mov	DWORD PTR [ecx], OFFSET _MemoryTrackerCS

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	mov	eax, OFFSET _MemoryTrackerCS
	lock	 bts	 DWORD PTR [eax], 0
	jae	SHORT $LN15@Lock
$LL5@Lock:
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h

; 39   : inline void YieldThread() { _mm_pause(); };

	pause
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 26   : 			if (_interlockedbittestandset(&Flag, 0) == 0) return;

	lock	 bts	 DWORD PTR [eax], 0
	jb	SHORT $LL5@Lock
$LN15@Lock:

; 46   : 			cs.Enter();
; 47   : 		};

	mov	eax, ecx
	ret	4
??0Lock@FastCriticalSection@@QAE@AAV1@@Z ENDP		; FastCriticalSection::Lock::Lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
;	COMDAT ??1Lock@FastCriticalSection@@QAE@XZ
_TEXT	SEGMENT
??1Lock@FastCriticalSection@@QAE@XZ PROC		; FastCriticalSection::Lock::~Lock, COMDAT
; _this$ = ecx

; 32   : 		Flag = 0;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax], 0

; 50   : 			cs.Leave();
; 51   : 		};

	ret	0
??1Lock@FastCriticalSection@@QAE@XZ ENDP		; FastCriticalSection::Lock::~Lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ??__EMemoryTrackerCS@@YAXXZ
text$yc	SEGMENT
??__EMemoryTrackerCS@@YAXXZ PROC			; `dynamic initializer for 'MemoryTrackerCS'', COMDAT
; File x:\github\renegade\dragonade_rxd\memorymanager\fastcriticalsection.h

; 20   : 	inline FastCriticalSection(): Flag(0) {};

	mov	DWORD PTR _MemoryTrackerCS, 0
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 39   : static FastCriticalSection					MemoryTrackerCS;

	ret	0
??__EMemoryTrackerCS@@YAXXZ ENDP			; `dynamic initializer for 'MemoryTrackerCS''
text$yc	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ??__ETagAllocator@@YAXXZ
text$yc	SEGMENT
??__ETagAllocator@@YAXXZ PROC				; `dynamic initializer for 'TagAllocator'', COMDAT

; 40   : static FastObjectAllocator<AllocationUnit>	TagAllocator;

	push	ebx
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	mov	ebx, OFFSET _TagAllocator
	test	bl, 7
	je	SHORT $LN13@dynamic
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN13@dynamic:
	mov	eax, OFFSET _TagAllocator+8
	xorps	xmm0, xmm0

; 62   : 		Value = 0;

	movlpd	QWORD PTR _TagAllocator+8, xmm0

; 63   : 		assert(((size_t) this % PLATFORM_MEMORY_ALIGNMENT) == 0); // make sure we are aligned!

	test	al, 7
	je	SHORT $LN20@dynamic
	push	63					; 0000003fH
	push	OFFSET ??_C@_1HA@PFFIGKEC@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1GC@IPODKEJ@?$AA?$CI?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?5?$AAt?$AAh?$AAi?$AAs?$AA?5?$AA?$CF?$AA?5?$AAP?$AAL?$AAA?$AAT?$AAF?$AAO?$AAR?$AAM?$AA_?$AAM?$AAE?$AAM?$AAO?$AAR?$AAY@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN20@dynamic:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 329  : 		allocator.Grow();

	mov	ecx, ebx

; 103  : {

	mov	DWORD PTR _TagAllocator+20, 0
	mov	DWORD PTR _TagAllocator+24, 0
	mov	DWORD PTR _TagAllocator+28, 0

; 104  : 	Init(element_size);
; 105  : };
; 106  : 
; 107  : inline FastFixedAllocator::~FastFixedAllocator() // *not* thread safe
; 108  : {
; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())
; 110  : 	{
; 111  : 		delete n;
; 112  : 	};
; 113  : };
; 114  : 
; 115  : inline void FastFixedAllocator::Grow()
; 116  : {
; 117  : 	Chunk* n = new Chunk;
; 118  : 	Chunks.Push(n);
; 119  : 
; 120  : #ifdef FASTALLOC_STATS
; 121  : 	_InterlockedExchangeAdd((long *)&TotalHeapSize, sizeof(Chunk));
; 122  : #endif
; 123  : 
; 124  : 	const size_t number_elements = Chunk::size / ElementSize;
; 125  : 
; 126  : 	for (size_t i = 0; i < number_elements; ++i)
; 127  : 	{
; 128  : 		Link* link = (Link*)(n->Memory + (i * ElementSize) );
; 129  : 		link->Next = 0;
; 130  : 		FreeList.Push(link);
; 131  : 	};
; 132  : };
; 133  : 
; 134  : inline void FastFixedAllocator::Init(size_t element_size)
; 135  : {
; 136  : 	this->ElementSize = element_size < sizeof(Link) ? sizeof (Link) : element_size;

	mov	DWORD PTR _TagAllocator+16, 332		; 0000014cH

; 329  : 		allocator.Grow();

	call	?Grow@FastFixedAllocator@@QAEXXZ	; FastFixedAllocator::Grow
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 40   : static FastObjectAllocator<AllocationUnit>	TagAllocator;

	push	OFFSET ??__FTagAllocator@@YAXXZ		; `dynamic atexit destructor for 'TagAllocator''
	call	_atexit
	add	esp, 4
	pop	ebx
	ret	0
??__ETagAllocator@@YAXXZ ENDP				; `dynamic initializer for 'TagAllocator''
text$yc	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ??__FTagAllocator@@YAXXZ
text$yd	SEGMENT
??__FTagAllocator@@YAXXZ PROC				; `dynamic atexit destructor for 'TagAllocator'', COMDAT
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 308  : 		return (T*) TSListBase::Pop();

	mov	ecx, OFFSET _TagAllocator+8
	call	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())

	test	eax, eax
	je	SHORT $LN5@dynamic
	push	esi
	mov	esi, DWORD PTR __imp__free
$LL7@dynamic:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 36   : 	free(memory);

	push	eax
	call	esi
	add	esp, 4
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 308  : 		return (T*) TSListBase::Pop();

	mov	ecx, OFFSET _TagAllocator+8
	call	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())

	test	eax, eax
	jne	SHORT $LL7@dynamic
	pop	esi
$LN5@dynamic:

; 110  : 	{
; 111  : 		delete n;
; 112  : 	};
; 113  : };

	call	??1?$TSList@UChunk@FastFixedAllocator@@@@QAE@XZ
	jmp	??1?$TSList@ULink@FastFixedAllocator@@@@QAE@XZ
??__FTagAllocator@@YAXXZ ENDP				; `dynamic atexit destructor for 'TagAllocator''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ??__ETags@@YAXXZ
text$yc	SEGMENT
??__ETags@@YAXXZ PROC					; `dynamic initializer for 'Tags'', COMDAT

; 41   : static DList<AllocationUnit>				Tags;

	push	OFFSET ??__FTags@@YAXXZ			; `dynamic atexit destructor for 'Tags''
	call	_atexit
	pop	ecx
	ret	0
??__ETags@@YAXXZ ENDP					; `dynamic initializer for 'Tags''
text$yc	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??__FTags@@YAXXZ
text$yd	SEGMENT
??__FTags@@YAXXZ PROC					; `dynamic atexit destructor for 'Tags'', COMDAT

; 47   : 		assert(this->Head == NULL); // If head is not NULL, then this list is not empty

	cmp	DWORD PTR _Tags, 0
	je	SHORT $LN7@dynamic
	push	47					; 0000002fH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@HEKIGBGD@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN7@dynamic:

; 48   : 		assert(this->Tail == NULL); // If tail is not NULL, then etc

	cmp	DWORD PTR _Tags+4, 0
	je	SHORT $LN8@dynamic
	push	48					; 00000030H
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@OMNJOPJE@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN8@dynamic:
	ret	0
??__FTags@@YAXXZ ENDP					; `dynamic atexit destructor for 'Tags''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??0?$DList@VAllocationUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$DList@VAllocationUnit@@@@QAE@XZ PROC		; DList<AllocationUnit>::DList<AllocationUnit>, COMDAT
; _this$dead$ = ecx

; 41   : 	{

	mov	DWORD PTR _Tags, 0
	mov	DWORD PTR _Tags+4, 0
	mov	eax, OFFSET _Tags
	ret	0
??0?$DList@VAllocationUnit@@@@QAE@XZ ENDP		; DList<AllocationUnit>::DList<AllocationUnit>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??1?$DList@VAllocationUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$DList@VAllocationUnit@@@@QAE@XZ PROC		; DList<AllocationUnit>::~DList<AllocationUnit>, COMDAT
; _this$dead$ = ecx

; 47   : 		assert(this->Head == NULL); // If head is not NULL, then this list is not empty

	cmp	DWORD PTR _Tags, 0
	je	SHORT $LN5@DList
	push	47					; 0000002fH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@HEKIGBGD@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAH?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN5@DList:

; 48   : 		assert(this->Tail == NULL); // If tail is not NULL, then etc

	cmp	DWORD PTR _Tags+4, 0
	je	SHORT $LN6@DList
	push	48					; 00000030H
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@OMNJOPJE@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAT?$AAa?$AAi?$AAl?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN6@DList:
	ret	0
??1?$DList@VAllocationUnit@@@@QAE@XZ ENDP		; DList<AllocationUnit>::~DList<AllocationUnit>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ??__EMemoryTrackerInstance@@YAXXZ
text$yc	SEGMENT
??__EMemoryTrackerInstance@@YAXXZ PROC			; `dynamic initializer for 'MemoryTrackerInstance'', COMDAT

; 42   : static MemoryTracker						MemoryTrackerInstance;

	push	OFFSET ??__FMemoryTrackerInstance@@YAXXZ ; `dynamic atexit destructor for 'MemoryTrackerInstance''
	call	_atexit
	pop	ecx
	ret	0
??__EMemoryTrackerInstance@@YAXXZ ENDP			; `dynamic initializer for 'MemoryTrackerInstance''
text$yc	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__FMemoryTrackerInstance@@YAXXZ
text$yd	SEGMENT
??__FMemoryTrackerInstance@@YAXXZ PROC			; `dynamic atexit destructor for 'MemoryTrackerInstance'', COMDAT
	jmp	??1MemoryTracker@@QAE@XZ		; MemoryTracker::~MemoryTracker
??__FMemoryTrackerInstance@@YAXXZ ENDP			; `dynamic atexit destructor for 'MemoryTrackerInstance''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ??2AllocationUnit@@SAPAXI@Z
_TEXT	SEGMENT
??2AllocationUnit@@SAPAXI@Z PROC			; AllocationUnit::operator new, COMDAT
; _size$dead$ = ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 339  : 		return allocator.Allocate();

	mov	ecx, OFFSET _TagAllocator
	jmp	?Allocate@FastFixedAllocator@@QAEPAXXZ	; FastFixedAllocator::Allocate
??2AllocationUnit@@SAPAXI@Z ENDP			; AllocationUnit::operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ??3AllocationUnit@@SAXPAX@Z
_TEXT	SEGMENT
??3AllocationUnit@@SAXPAX@Z PROC			; AllocationUnit::operator delete, COMDAT
; _memory$ = ecx

; 54   : {

	push	esi
	mov	esi, ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 158  : 	assert(memory); // If you hit this assert, you tried to free NULL. NULL doesn't want to be free ;)

	test	esi, esi
	jne	SHORT $LN7@operator
	push	158					; 0000009eH
	push	OFFSET ??_C@_1HO@PBNFMELI@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN7@operator:

; 159  : #ifdef FASTALLOC_STATS
; 160  : 	_InterlockedDecrement((long*)&TotalAllocationCount);

	mov	ecx, OFFSET _TagAllocator+28
	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx], eax

; 161  : 	_InterlockedExchangeAdd((long*)&TotalAllocatedSize, -(long)ElementSize);

	mov	eax, DWORD PTR _TagAllocator+16
	neg	eax
	mov	ecx, OFFSET _TagAllocator+24
	lock	 xadd	 DWORD PTR [ecx], eax
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	push	esi
	mov	ecx, OFFSET _TagAllocator
	call	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
	pop	esi
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 56   : };

	ret	0
??3AllocationUnit@@SAXPAX@Z ENDP			; AllocationUnit::operator delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ??1MemoryTracker@@QAE@XZ
_TEXT	SEGMENT
_path_to_exe$ = -512					; size = 256
_buffer$1 = -256					; size = 256
??1MemoryTracker@@QAE@XZ PROC				; MemoryTracker::~MemoryTracker, COMDAT
; _this$dead$ = ecx

; 60   : {

	sub	esp, 512				; 00000200H

; 61   : 	char path_to_exe[256];
; 62   : 	GetModuleFileNameA(NULL, path_to_exe, sizeof(path_to_exe));

	lea	eax, DWORD PTR _path_to_exe$[esp+512]
	push	edi
	push	256					; 00000100H
	push	eax
	push	0
	call	DWORD PTR __imp__GetModuleFileNameA@12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h

; 222  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

	lea	eax, DWORD PTR _path_to_exe$[esp+516]
	push	92					; 0000005cH
	push	eax
	call	DWORD PTR __imp__strrchr
	add	esp, 8
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 63   : 	strrchr(path_to_exe,'\\')[0] = 0;

	mov	BYTE PTR [eax], 0

; 64   : 	SetCurrentDirectoryA(path_to_exe);

	lea	eax, DWORD PTR _path_to_exe$[esp+516]
	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryA@4

; 65   : 	strcat(path_to_exe,"\\");

	lea	edi, DWORD PTR _path_to_exe$[esp+516]
	dec	edi
	npad	5
$LL50@MemoryTrac:
	mov	al, BYTE PTR [edi+1]
	lea	edi, DWORD PTR [edi+1]
	test	al, al
	jne	SHORT $LL50@MemoryTrac
	mov	ax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@

; 66   : 	strcat(path_to_exe,LEAK_LOG_DIR);

	lea	ecx, DWORD PTR _path_to_exe$[esp+516]
	mov	WORD PTR [edi], ax
	dec	ecx
$LL51@MemoryTrac:
	mov	al, BYTE PTR [ecx+1]
	lea	ecx, DWORD PTR [ecx+1]
	test	al, al
	jne	SHORT $LL51@MemoryTrac
	mov	eax, DWORD PTR ??_C@_0N@LFFEOAII@debug?2memory?$AA@
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ??_C@_0N@LFFEOAII@debug?2memory?$AA@+4
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ??_C@_0N@LFFEOAII@debug?2memory?$AA@+8
	mov	DWORD PTR [ecx+8], eax
	mov	al, BYTE PTR ??_C@_0N@LFFEOAII@debug?2memory?$AA@+12
	mov	BYTE PTR [ecx+12], al

; 67   : 	if (!PathFileExistsA(path_to_exe))

	lea	eax, DWORD PTR _path_to_exe$[esp+516]
	push	eax
	call	DWORD PTR __imp__PathFileExistsA@4
	test	eax, eax
	jne	SHORT $LN17@MemoryTrac

; 68   : 	{
; 69   : 		SHCreateDirectoryExA(NULL,path_to_exe,NULL);

	push	eax
	lea	eax, DWORD PTR _path_to_exe$[esp+520]
	push	eax
	push	0
	call	DWORD PTR __imp__SHCreateDirectoryExA@12
$LN17@MemoryTrac:

; 70   : 	}
; 71   : 	FILE* leakLogFile = fopen(LEAK_LOG_DIR "\\leaks.txt", "wb");

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	OFFSET ??_C@_0BH@FABFNODC@debug?2memory?2leaks?4txt?$AA@
	call	DWORD PTR __imp__fopen
	mov	edi, eax
	add	esp, 8

; 72   : 	if (!leakLogFile)

	test	edi, edi
	jne	SHORT $LN16@MemoryTrac

; 73   : 		OutputDebugStringA("Failed to write to " LEAK_LOG_DIR "\\leaks.txt");

	push	OFFSET ??_C@_0CK@FBKOEIAE@Failed?5to?5write?5to?5debug?2memory?2@
	call	DWORD PTR __imp__OutputDebugStringA@4
	pop	edi

; 117  : 	}
; 118  : };

	add	esp, 512				; 00000200H
	ret	0
$LN16@MemoryTrac:
	push	ebx
	push	esi

; 74   : 	else
; 75   : 	{
; 76   : 		fprintf(leakLogFile, "address\tsize\tfile\tfunction\tline\tallocation type\r\n");

	push	OFFSET ??_C@_0DC@DDHDNAPJ@address?7size?7file?7function?7line?7@
	push	edi
	call	DWORD PTR __imp__fprintf
	add	esp, 8

; 77   : 		int LeakCount = 0;

	xor	ebx, ebx
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 217  : 		return (T*)DListBase::PopHead();

	call	?PopHead@DListBase@@QAEPAVDLNodeBase@@XZ ; DListBase::PopHead
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 78   : 		for (AllocationUnit* tag = Tags.PopHead(); tag; tag = Tags.PopHead() )

	mov	esi, eax
	test	esi, esi
	je	$LN1@MemoryTrac
	npad	4
$LL14@MemoryTrac:

; 79   : 		{
; 80   : 			const char* allocationTypeName;
; 81   : 			switch (tag->AllocationType)

	mov	eax, DWORD PTR [esi+288]
	jmp	DWORD PTR $LN55@MemoryTrac[eax*4]
$LN9@MemoryTrac:

; 82   : 			{
; 83   : 			case AllocType_Unknown: allocationTypeName = "unknown"; break;

	mov	eax, OFFSET ??_C@_07CIFAGBMG@unknown?$AA@
	jmp	SHORT $LN10@MemoryTrac
$LN8@MemoryTrac:

; 84   : 			case AllocType_New: allocationTypeName = "new"; break;

	mov	eax, OFFSET ??_C@_03CLCAEGCJ@new?$AA@
	jmp	SHORT $LN10@MemoryTrac
$LN7@MemoryTrac:

; 85   : 			case AllocType_VectorNew: allocationTypeName = "new[]"; break;

	mov	eax, OFFSET ??_C@_05LEAFLCCG@new?$FL?$FN?$AA@
	jmp	SHORT $LN10@MemoryTrac
$LN6@MemoryTrac:

; 86   : 			case AllocType_Malloc: allocationTypeName = "malloc"; break;

	mov	eax, OFFSET ??_C@_06GLDDLHNF@malloc?$AA@
	jmp	SHORT $LN10@MemoryTrac
$LN5@MemoryTrac:

; 87   : 			case AllocType_Calloc: allocationTypeName = "calloc"; break;

	mov	eax, OFFSET ??_C@_06DLAMMMII@calloc?$AA@
	jmp	SHORT $LN10@MemoryTrac
$LN4@MemoryTrac:

; 88   : 			case AllocType_Realloc: allocationTypeName = "realloc"; break;

	mov	eax, OFFSET ??_C@_07EOOHGPEI@realloc?$AA@
	jmp	SHORT $LN10@MemoryTrac
$LN3@MemoryTrac:

; 89   : 			case AllocType_Unvalidated: allocationTypeName = "unvalidated"; break;

	mov	eax, OFFSET ??_C@_0M@IPKDCNKC@unvalidated?$AA@
$LN10@MemoryTrac:

; 90   : 			default: __assume(false);
; 91   : 			}
; 92   : 			LeakCount++;
; 93   : 			fprintf(leakLogFile, "0x%08p\t0x%04IX (%Iu)\t%.128s\t%.128s\t%d\t%s\r\n", tag->ReportedAddress, tag->ReportedSize, tag->ReportedSize, tag->SourceFile, tag->SourceFunction, tag->SourceLine, allocationTypeName);

	mov	ecx, DWORD PTR [esi+24]
	push	eax
	push	DWORD PTR [esi+284]
	lea	eax, DWORD PTR [esi+156]
	push	eax
	lea	eax, DWORD PTR [esi+28]
	push	eax
	push	ecx
	push	ecx
	push	DWORD PTR [esi+20]
	inc	ebx
	push	OFFSET ??_C@_0CL@FJOGLINP@0x?$CF08p?70x?$CF04IX?5?$CI?$CFIu?$CJ?7?$CF?4128s?7?$CF?412@
	push	edi
	call	DWORD PTR __imp__fprintf
	add	esp, 36					; 00000024H
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 159  : 	assert(this->List == NULL); // If list is not NULL, then you forgot to remove this item before deleting it.

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN37@MemoryTrac
	push	159					; 0000009fH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@ICFGHNLI@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN37@MemoryTrac:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 160  : 	_InterlockedDecrement((long*)&TotalAllocationCount);

	or	eax, -1
	mov	ecx, OFFSET _TagAllocator+28
	lock	 xadd	 DWORD PTR [ecx], eax

; 161  : 	_InterlockedExchangeAdd((long*)&TotalAllocatedSize, -(long)ElementSize);

	mov	eax, DWORD PTR _TagAllocator+16
	neg	eax
	mov	ecx, OFFSET _TagAllocator+24
	lock	 xadd	 DWORD PTR [ecx], eax
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	push	esi
	mov	ecx, OFFSET _TagAllocator
	call	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 217  : 		return (T*)DListBase::PopHead();

	call	?PopHead@DListBase@@QAEPAVDLNodeBase@@XZ ; DListBase::PopHead
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 78   : 		for (AllocationUnit* tag = Tags.PopHead(); tag; tag = Tags.PopHead() )

	mov	esi, eax
	test	esi, esi
	jne	$LL14@MemoryTrac

; 94   : 
; 95   : 	#if DETAILED_LEAK_LOGS
; 96   : 			char detailedLeakLogFilePath[MAX_PATH];
; 97   : 			sprintf(detailedLeakLogFilePath, LEAK_LOG_DIR "\\leak-stack-%08X.txt", tag->ReportedAddress);
; 98   : 			FILE* detailedLeakLog = fopen(detailedLeakLogFilePath, "wb");
; 99   : 			fwrite(tag->stack, 1, sizeof(tag->stack), detailedLeakLog);
; 100  : 			fclose(detailedLeakLog);
; 101  : 
; 102  : 			sprintf(detailedLeakLogFilePath, LEAK_LOG_DIR "\\leak-data-%08X.txt", tag->ReportedAddress);
; 103  : 			detailedLeakLog = fopen(detailedLeakLogFilePath, "wb");
; 104  : 			fwrite(tag->ReportedAddress, 1, tag->ReportedSize, detailedLeakLog);
; 105  : 			fclose(detailedLeakLog);
; 106  : 	#endif
; 107  : 
; 108  : 			delete tag;
; 109  : 		}
; 110  : 		if (LeakCount)

	test	ebx, ebx
	je	SHORT $LN1@MemoryTrac

; 111  : 		{
; 112  : 			char buffer[256];
; 113  : 			sprintf(buffer,"%d Memory Leaks found\n",LeakCount);

	push	ebx
	lea	eax, DWORD PTR _buffer$1[esp+528]
	push	OFFSET ??_C@_0BH@FOPENCFM@?$CFd?5Memory?5Leaks?5found?6?$AA@
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 114  : 			OutputDebugStringA(buffer);

	lea	eax, DWORD PTR _buffer$1[esp+524]
	push	eax
	call	DWORD PTR __imp__OutputDebugStringA@4
$LN1@MemoryTrac:

; 115  : 		}
; 116  : 		fclose(leakLogFile);

	push	edi
	call	DWORD PTR __imp__fclose
	add	esp, 4
	pop	esi
	pop	ebx
	pop	edi

; 117  : 	}
; 118  : };

	add	esp, 512				; 00000200H
	ret	0
	npad	1
$LN55@MemoryTrac:
	DD	$LN9@MemoryTrac
	DD	$LN8@MemoryTrac
	DD	$LN7@MemoryTrac
	DD	$LN6@MemoryTrac
	DD	$LN5@MemoryTrac
	DD	$LN4@MemoryTrac
	DD	$LN3@MemoryTrac
??1MemoryTracker@@QAE@XZ ENDP				; MemoryTracker::~MemoryTracker
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ??_GAllocationUnit@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GAllocationUnit@@QAEPAXI@Z PROC			; AllocationUnit::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h

; 159  : 	assert(this->List == NULL); // If list is not NULL, then you forgot to remove this item before deleting it.

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN10@scalar
	push	159					; 0000009fH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@ICFGHNLI@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN10@scalar:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 160  : 	_InterlockedDecrement((long*)&TotalAllocationCount);

	mov	ecx, OFFSET _TagAllocator+28
	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx], eax

; 161  : 	_InterlockedExchangeAdd((long*)&TotalAllocatedSize, -(long)ElementSize);

	mov	eax, DWORD PTR _TagAllocator+16
	neg	eax
	mov	ecx, OFFSET _TagAllocator+24
	lock	 xadd	 DWORD PTR [ecx], eax
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	push	esi
	mov	ecx, OFFSET _TagAllocator
	call	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
	mov	eax, esi
	pop	esi
	ret	4
??_GAllocationUnit@@QAEPAXI@Z ENDP			; AllocationUnit::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ??1AllocationUnit@@QAE@XZ
_TEXT	SEGMENT
??1AllocationUnit@@QAE@XZ PROC				; AllocationUnit::~AllocationUnit, COMDAT
; _this$ = ecx

; 159  : 	assert(this->List == NULL); // If list is not NULL, then you forgot to remove this item before deleting it.

	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN7@Allocation
	push	159					; 0000009fH
	push	OFFSET ??_C@_1GO@BEDELNHP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1CG@ICFGHNLI@?$AAt?$AAh?$AAi?$AAs?$AA?9?$AA?$DO?$AAL?$AAi?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN7@Allocation:
	ret	0
??1AllocationUnit@@QAE@XZ ENDP				; AllocationUnit::~AllocationUnit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?FilePathStripper@@YAPBDPBD@Z
_TEXT	SEGMENT
?FilePathStripper@@YAPBDPBD@Z PROC			; FilePathStripper, COMDAT
; _source_file$ = ecx

; 130  : {

	push	esi
	mov	esi, ecx

; 131  : 	const char* ptr = strrchr(source_file, '\\');

	push	92					; 0000005cH
	push	esi
	call	DWORD PTR __imp__strrchr
	add	esp, 8

; 132  : 	if (ptr) return ptr + 1;

	test	eax, eax
	je	SHORT $LN2@FilePathSt
$LN5@FilePathSt:
	inc	eax
	pop	esi

; 136  : }

	ret	0
$LN2@FilePathSt:

; 133  : 	ptr = strrchr(source_file, '/');

	push	47					; 0000002fH
	push	esi
	call	DWORD PTR __imp__strrchr
	add	esp, 8

; 134  : 	if (ptr) return ptr + 1;

	test	eax, eax
	jne	SHORT $LN5@FilePathSt

; 135  : 	return source_file;

	mov	eax, esi
	pop	esi

; 136  : }

	ret	0
?FilePathStripper@@YAPBDPBD@Z ENDP			; FilePathStripper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?GetMemoryTrackingCost@MemoryTracker@@KA?BIXZ
_TEXT	SEGMENT
?GetMemoryTrackingCost@MemoryTracker@@KA?BIXZ PROC	; MemoryTracker::GetMemoryTrackingCost, COMDAT

; 140  : 	// pointer size + sentinel size
; 141  : 	return sizeof(AllocationUnit*) + (SENTINEL_SIZE * sizeof(int32) * 2);

	mov	eax, 68					; 00000044H

; 142  : };

	ret	0
?GetMemoryTrackingCost@MemoryTracker@@KA?BIXZ ENDP	; MemoryTracker::GetMemoryTrackingCost
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?FindAllocationUnit@MemoryTracker@@KAPAVAllocationUnit@@PAX@Z
_TEXT	SEGMENT
?FindAllocationUnit@MemoryTracker@@KAPAVAllocationUnit@@PAX@Z PROC ; MemoryTracker::FindAllocationUnit, COMDAT
; _memory$ = ecx

; 146  : 	void* actual = CalculateActualAddress(memory);
; 147  : 	int32* sentinel_start =  (int32*)((char*) actual + sizeof(AllocationUnit*));
; 148  : 	if (*sentinel_start != PREFIX_PATTERN) return NULL; // preliminary validation

	cmp	DWORD PTR [ecx-32], -1163005939		; baadf00dH
	je	SHORT $LN1@FindAlloca
	xor	eax, eax

; 150  : };

	ret	0
$LN1@FindAlloca:

; 149  : 	return *(AllocationUnit**) actual;

	mov	eax, DWORD PTR [ecx-36]

; 150  : };

	ret	0
?FindAllocationUnit@MemoryTracker@@KAPAVAllocationUnit@@PAX@Z ENDP ; MemoryTracker::FindAllocationUnit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?WipeMemoryWithPattern@MemoryTracker@@KAXPAVAllocationUnit@@HI@Z
_TEXT	SEGMENT
_bias$dead$ = 8						; size = 4
?WipeMemoryWithPattern@MemoryTracker@@KAXPAVAllocationUnit@@HI@Z PROC ; MemoryTracker::WipeMemoryWithPattern, COMDAT
; _unit$ = ecx
; _pattern$dead$ = edx
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h

; 144  : 		return (char*)unit->ReportedAddress + unit->ReportedSize;

	mov	eax, DWORD PTR [ecx+24]

; 138  : 		return (char*)unit->ActualAddress + sizeof(AllocationUnit*);

	mov	edx, DWORD PTR [ecx+12]

; 144  : 		return (char*)unit->ReportedAddress + unit->ReportedSize;

	add	eax, DWORD PTR [ecx+20]
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 180  : 		*pre = PREFIX_PATTERN;

	mov	DWORD PTR [edx+4], -1163005939		; baadf00dH

; 181  : 		*post = POSTFIX_PATTERN;

	mov	DWORD PTR [eax], -559038242		; deadc0deH
	mov	DWORD PTR [edx+8], -1163005939		; baadf00dH
	mov	DWORD PTR [eax+4], -559038242		; deadc0deH
	mov	DWORD PTR [edx+12], -1163005939		; baadf00dH
	mov	DWORD PTR [eax+8], -559038242		; deadc0deH
	mov	DWORD PTR [edx+16], -1163005939		; baadf00dH
	mov	DWORD PTR [eax+12], -559038242		; deadc0deH
	mov	DWORD PTR [edx+20], -1163005939		; baadf00dH
	mov	DWORD PTR [eax+16], -559038242		; deadc0deH
	mov	DWORD PTR [edx+24], -1163005939		; baadf00dH
	mov	DWORD PTR [eax+20], -559038242		; deadc0deH
	mov	DWORD PTR [edx+28], -1163005939		; baadf00dH
	mov	DWORD PTR [eax+24], -559038242		; deadc0deH
	mov	DWORD PTR [edx+32], -1163005939		; baadf00dH
	mov	DWORD PTR [eax+28], -559038242		; deadc0deH

; 182  : 	};
; 183  : };

	ret	0
?WipeMemoryWithPattern@MemoryTracker@@KAXPAVAllocationUnit@@HI@Z ENDP ; MemoryTracker::WipeMemoryWithPattern
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp
;	COMDAT ?ValidateAllocationUnit@MemoryTracker@@KA_NPAVAllocationUnit@@@Z
_TEXT	SEGMENT
tv195 = -4						; size = 4
?ValidateAllocationUnit@MemoryTracker@@KA_NPAVAllocationUnit@@@Z PROC ; MemoryTracker::ValidateAllocationUnit, COMDAT
; _unit$ = ecx

; 187  : {

	push	ecx
	push	ebx
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h

; 138  : 		return (char*)unit->ActualAddress + sizeof(AllocationUnit*);

	mov	ebx, DWORD PTR __imp___wassert
	push	ebp
	push	esi

; 139  : 	};
; 140  : 
; 141  : 	static inline void* CalculatePostfixSentinelStartAddress(AllocationUnit* unit)
; 142  : 	{
; 143  : 		// memory start + memory size
; 144  : 		return (char*)unit->ReportedAddress + unit->ReportedSize;

	mov	esi, DWORD PTR [ecx+24]
	add	esi, DWORD PTR [ecx+20]
	push	edi

; 138  : 		return (char*)unit->ActualAddress + sizeof(AllocationUnit*);

	mov	edi, DWORD PTR [ecx+12]
	add	edi, 4
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 191  : 	bool error_flag = false;

	xor	dl, dl
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.h

; 138  : 		return (char*)unit->ActualAddress + sizeof(AllocationUnit*);

	mov	ebp, 8
	npad	2
$LL5@ValidateAl:
; File x:\github\renegade\dragonade_rxd\memorymanager\memtracker.cpp

; 194  : 		if (*pre != PREFIX_PATTERN)

	cmp	DWORD PTR [edi], -1163005939		; baadf00dH
	movzx	eax, dl
	mov	edx, 1
	cmovne	eax, edx

; 195  : 		{
; 196  : 			// log this event maybe?
; 197  : 			error_flag = true;
; 198  : 		}
; 199  : 
; 200  : 		if (*post != POSTFIX_PATTERN) 

	cmp	DWORD PTR [esi], -559038242		; deadc0deH
	movzx	eax, al
	cmovne	eax, edx

; 201  : 		{
; 202  : 			// this one too?
; 203  : 			error_flag = true;
; 204  : 		}
; 205  : 		
; 206  : 		// If you hit this assert, the sentinel before the allocation has been damaged 
; 207  : 		assert(*pre == PREFIX_PATTERN);

	cmp	DWORD PTR [edi], -1163005939		; baadf00dH
	mov	DWORD PTR tv195[esp+20], eax
	je	SHORT $LN8@ValidateAl
	push	207					; 000000cfH
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1CO@POGMJGLI@?$AA?$CK?$AAp?$AAr?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAR?$AAE?$AAF?$AAI?$AAX?$AA_?$AAP?$AAA?$AAT?$AAT?$AAE?$AAR?$AAN?$AA?$AA@
	call	ebx
	add	esp, 12					; 0000000cH
$LN8@ValidateAl:

; 208  : 
; 209  : 		// If you hit this assert, the sentinel after the allocation has been damaged
; 210  : 		assert(*post == POSTFIX_PATTERN);

	cmp	DWORD PTR [esi], -559038242		; deadc0deH
	je	SHORT $LN4@ValidateAl
	push	210					; 000000d2H
	push	OFFSET ??_C@_1BO@ODDDPHMM@?$AAM?$AAe?$AAm?$AAT?$AAr?$AAa?$AAc?$AAk?$AAe?$AAr?$AA?4?$AAc?$AAp?$AAp?$AA?$AA@
	push	OFFSET ??_C@_1DC@HBEBNFEC@?$AA?$CK?$AAp?$AAo?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAO?$AAS?$AAT?$AAF?$AAI?$AAX?$AA_?$AAP?$AAA?$AAT?$AAT?$AAE?$AAR?$AAN?$AA?$AA@
	call	ebx
	add	esp, 12					; 0000000cH
$LN4@ValidateAl:

; 192  : 	for (size_t i = 0; i < SENTINEL_SIZE; ++i, ++pre, ++post)

	mov	edx, DWORD PTR tv195[esp+20]
	add	edi, 4
	add	esi, 4
	dec	ebp
	jne	SHORT $LL5@ValidateAl

; 211  : 	};
; 212  : 	
; 213  : 	return !error_flag;

	pop	edi
	pop	esi
	xor	eax, eax
	test	dl, dl
	pop	ebp
	sete	al
	pop	ebx

; 214  : };

	pop	ecx
	ret	0
?ValidateAllocationUnit@MemoryTracker@@KA_NPAVAllocationUnit@@@Z ENDP ; MemoryTracker::ValidateAllocationUnit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
;	COMDAT ?Pop@?$TSList@ULink@FastFixedAllocator@@@@QAEPAULink@FastFixedAllocator@@XZ
_TEXT	SEGMENT
?Pop@?$TSList@ULink@FastFixedAllocator@@@@QAEPAULink@FastFixedAllocator@@XZ PROC ; TSList<FastFixedAllocator::Link>::Pop, COMDAT
; _this$ = ecx

; 308  : 		return (T*) TSListBase::Pop();

	jmp	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
?Pop@?$TSList@ULink@FastFixedAllocator@@@@QAEPAULink@FastFixedAllocator@@XZ ENDP ; TSList<FastFixedAllocator::Link>::Pop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ??0?$FastObjectAllocator@VAllocationUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FastObjectAllocator@VAllocationUnit@@@@QAE@XZ PROC	; FastObjectAllocator<AllocationUnit>::FastObjectAllocator<AllocationUnit>, COMDAT
; _this$dead$ = ecx

; 326  : 	FastObjectAllocator()

	push	ecx
	mov	ecx, OFFSET _TagAllocator
	call	??0FastFixedAllocator@@QAE@I@Z		; FastFixedAllocator::FastFixedAllocator

; 327  : 	{
; 328  : 		allocator.Init(sizeof(T));
; 329  : 		allocator.Grow();

	mov	ecx, OFFSET _TagAllocator

; 136  : 	this->ElementSize = element_size < sizeof(Link) ? sizeof (Link) : element_size;

	mov	DWORD PTR _TagAllocator+16, 332		; 0000014cH

; 327  : 	{
; 328  : 		allocator.Init(sizeof(T));
; 329  : 		allocator.Grow();

	call	?Grow@FastFixedAllocator@@QAEXXZ	; FastFixedAllocator::Grow

; 330  : 	};

	mov	eax, OFFSET _TagAllocator
	ret	0
??0?$FastObjectAllocator@VAllocationUnit@@@@QAE@XZ ENDP	; FastObjectAllocator<AllocationUnit>::FastObjectAllocator<AllocationUnit>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ??1?$FastObjectAllocator@VAllocationUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FastObjectAllocator@VAllocationUnit@@@@QAE@XZ PROC	; FastObjectAllocator<AllocationUnit>::~FastObjectAllocator<AllocationUnit>, COMDAT
; _this$dead$ = ecx
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 308  : 		return (T*) TSListBase::Pop();

	mov	ecx, OFFSET _TagAllocator+8
	call	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())

	test	eax, eax
	je	SHORT $LN3@FastObject
	push	esi
	mov	esi, DWORD PTR __imp__free
$LL5@FastObject:
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.cpp

; 36   : 	free(memory);

	push	eax
	call	esi
	add	esp, 4
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 308  : 		return (T*) TSListBase::Pop();

	mov	ecx, OFFSET _TagAllocator+8
	call	?Pop@_TSListBase32@@QAEPAU_TSLNode32@@XZ ; _TSListBase32::Pop
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h

; 109  : 	for (Chunk* n = (Chunk*)Chunks.Pop(); n; n = Chunks.Pop())

	test	eax, eax
	jne	SHORT $LL5@FastObject
	pop	esi
$LN3@FastObject:

; 334  : 		// TODO: make sure everything is free'd
; 335  : 	};

	ret	0
??1?$FastObjectAllocator@VAllocationUnit@@@@QAE@XZ ENDP	; FastObjectAllocator<AllocationUnit>::~FastObjectAllocator<AllocationUnit>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?Allocate@?$FastObjectAllocator@VAllocationUnit@@@@QAEPAXXZ
_TEXT	SEGMENT
?Allocate@?$FastObjectAllocator@VAllocationUnit@@@@QAEPAXXZ PROC ; FastObjectAllocator<AllocationUnit>::Allocate, COMDAT
; _this$dead$ = ecx

; 339  : 		return allocator.Allocate();

	mov	ecx, OFFSET _TagAllocator
	jmp	?Allocate@FastFixedAllocator@@QAEPAXXZ	; FastFixedAllocator::Allocate
?Allocate@?$FastObjectAllocator@VAllocationUnit@@@@QAEPAXXZ ENDP ; FastObjectAllocator<AllocationUnit>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h
; File x:\github\renegade\dragonade_rxd\memorymanager\fastallocator.h
;	COMDAT ?Free@?$FastObjectAllocator@VAllocationUnit@@@@QAEXPAX@Z
_TEXT	SEGMENT
_object$ = 8						; size = 4
?Free@?$FastObjectAllocator@VAllocationUnit@@@@QAEXPAX@Z PROC ; FastObjectAllocator<AllocationUnit>::Free, COMDAT
; _this$dead$ = ecx

; 158  : 	assert(memory); // If you hit this assert, you tried to free NULL. NULL doesn't want to be free ;)

	cmp	DWORD PTR _object$[esp-4], 0
	jne	SHORT $LN5@Free
	push	158					; 0000009eH
	push	OFFSET ??_C@_1HO@PBNFMELI@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1O@NIJNBMFJ@?$AAm?$AAe?$AAm?$AAo?$AAr?$AAy?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN5@Free:

; 159  : #ifdef FASTALLOC_STATS
; 160  : 	_InterlockedDecrement((long*)&TotalAllocationCount);

	mov	ecx, OFFSET _TagAllocator+28
	or	eax, -1
	lock	 xadd	 DWORD PTR [ecx], eax

; 161  : 	_InterlockedExchangeAdd((long*)&TotalAllocatedSize, -(long)ElementSize);

	mov	eax, DWORD PTR _TagAllocator+16
	neg	eax
	mov	ecx, OFFSET _TagAllocator+24
	lock	 xadd	 DWORD PTR [ecx], eax
; File x:\github\renegade\dragonade_rxd\memorymanager\tslist.h

; 303  : 		TSListBase::Push((TSLNode*) item); 

	mov	ecx, OFFSET _TagAllocator
	jmp	?Push@_TSListBase32@@QAEPAU_TSLNode32@@PAU2@@Z ; _TSListBase32::Push
?Free@?$FastObjectAllocator@VAllocationUnit@@@@QAEXPAX@Z ENDP ; FastObjectAllocator<AllocationUnit>::Free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\dlist.h
;	COMDAT ?PopHead@?$DList@VAllocationUnit@@@@QAEPAVAllocationUnit@@XZ
_TEXT	SEGMENT
?PopHead@?$DList@VAllocationUnit@@@@QAEPAVAllocationUnit@@XZ PROC ; DList<AllocationUnit>::PopHead, COMDAT
; _this$dead$ = ecx

; 217  : 		return (T*)DListBase::PopHead();

	jmp	?PopHead@DListBase@@QAEPAVDLNodeBase@@XZ ; DListBase::PopHead
?PopHead@?$DList@VAllocationUnit@@@@QAEPAVAllocationUnit@@XZ ENDP ; DList<AllocationUnit>::PopHead
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
;	COMDAT ??$UNUSED_VARIABLE@I@@YAXABI@Z
_TEXT	SEGMENT
??$UNUSED_VARIABLE@I@@YAXABI@Z PROC			; UNUSED_VARIABLE<unsigned int>, COMDAT
; ___formal$dead$ = ecx

; 50   : template <typename T> inline void UNUSED_VARIABLE(const T&) {};

	ret	0
??$UNUSED_VARIABLE@I@@YAXABI@Z ENDP			; UNUSED_VARIABLE<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
;	COMDAT ??$strncpy_s@$0IA@@@YAHAAY0IA@DPBDI@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
??$strncpy_s@$0IA@@@YAHAAY0IA@DPBDI@Z PROC		; strncpy_s<128>, COMDAT
; __Dest$ = ecx
; __Source$ = edx

; 190  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_reads_or_z_(_Count) const char *, _Source, _In_ size_t, _Count)

	push	-1
	push	edx
	push	128					; 00000080H
	push	ecx
	call	DWORD PTR __imp__strncpy_s
	add	esp, 16					; 00000010H
	ret	0
??$strncpy_s@$0IA@@@YAHAAY0IA@DPBDI@Z ENDP		; strncpy_s<128>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File x:\github\renegade\dragonade_rxd\memorymanager\platform.h
;	COMDAT ??$UNUSED_VARIABLE@PBD@@YAXABQBD@Z
_TEXT	SEGMENT
??$UNUSED_VARIABLE@PBD@@YAXABQBD@Z PROC			; UNUSED_VARIABLE<char const *>, COMDAT
; ___formal$dead$ = ecx

; 50   : template <typename T> inline void UNUSED_VARIABLE(const T&) {};

	ret	0
??$UNUSED_VARIABLE@PBD@@YAXABQBD@Z ENDP			; UNUSED_VARIABLE<char const *>
_TEXT	ENDS
END
