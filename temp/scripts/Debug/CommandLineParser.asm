; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61219.0 

	TITLE	X:\GitHub\Renegade\Dragonade_RxD\scripts\CommandLineParser.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?skipWhitespace@CommandLineParser@@AAE_NXZ	; CommandLineParser::skipWhitespace
PUBLIC	?skipToken@CommandLineParser@@AAEXXZ		; CommandLineParser::skipToken
PUBLIC	??0CommandLineParser@@QAE@PBD@Z			; CommandLineParser::CommandLineParser
PUBLIC	??1CommandLineParser@@QAE@XZ			; CommandLineParser::~CommandLineParser
PUBLIC	?skip@CommandLineParser@@QAEXXZ			; CommandLineParser::skip
PUBLIC	?getString@CommandLineParser@@QAEPBDXZ		; CommandLineParser::getString
PUBLIC	?getRemainingString@CommandLineParser@@QAEPBDXZ	; CommandLineParser::getRemainingString
PUBLIC	?getInt@CommandLineParser@@QAEHXZ		; CommandLineParser::getInt
PUBLIC	?getDouble@CommandLineParser@@QAENXZ		; CommandLineParser::getDouble
PUBLIC	??4CommandLineParser@@QAEAAV0@ABV0@@Z		; CommandLineParser::operator=
PUBLIC	?__LINE__Var@?1???0CommandLineParser@@QAE@PBD@Z@4JA ; `CommandLineParser::CommandLineParser'::`2'::__LINE__Var
PUBLIC	??_C@_0CF@OOHNGOIH@CommandLineParser?3?3CommandLinePa@ ; `string'
PUBLIC	??_C@_0DP@LNJJFPIC@x?3?2github?2renegade?2dragonade_rxd@ ; `string'
PUBLIC	??_C@_1HO@CLELPKJP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@ ; `string'
PUBLIC	??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?1???1CommandLineParser@@QAE@XZ@4JA ; `CommandLineParser::~CommandLineParser'::`2'::__LINE__Var
PUBLIC	??_C@_0CG@EOBEJLIK@CommandLineParser?3?3?$HOCommandLineP@ ; `string'
PUBLIC	__real@0000000000000000
EXTRN	__imp___wassert:PROC
EXTRN	__imp__atof:PROC
EXTRN	__imp__atoi:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?SetThreadTrackingInformation@@YAXPBDI0@Z:PROC	; SetThreadTrackingInformation
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0CG@EOBEJLIK@CommandLineParser?3?3?$HOCommandLineP@
CONST	SEGMENT
??_C@_0CG@EOBEJLIK@CommandLineParser?3?3?$HOCommandLineP@ DB 'CommandLine'
	DB	'Parser::~CommandLineParser', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1???1CommandLineParser@@QAE@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?1???1CommandLineParser@@QAE@XZ@4JA DD 01bH ; `CommandLineParser::~CommandLineParser'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@ DB 'f', 00H, 'a', 00H
	DB	'l', 00H, 's', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1HO@CLELPKJP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
CONST	SEGMENT
??_C@_1HO@CLELPKJP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@ DB 'x'
	DB	00H, ':', 00H, '\', 00H, 'g', 00H, 'i', 00H, 't', 00H, 'h', 00H
	DB	'u', 00H, 'b', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'e'
	DB	00H, 'g', 00H, 'a', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'd', 00H
	DB	'r', 00H, 'a', 00H, 'g', 00H, 'o', 00H, 'n', 00H, 'a', 00H, 'd'
	DB	00H, 'e', 00H, '_', 00H, 'r', 00H, 'x', 00H, 'd', 00H, '\', 00H
	DB	's', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 'p', 00H, 't', 00H, 's'
	DB	00H, '\', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'a', 00H
	DB	'n', 00H, 'd', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'p'
	DB	00H, 'a', 00H, 'r', 00H, 's', 00H, 'e', 00H, 'r', 00H, '.', 00H
	DB	'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@LNJJFPIC@x?3?2github?2renegade?2dragonade_rxd@
CONST	SEGMENT
??_C@_0DP@LNJJFPIC@x?3?2github?2renegade?2dragonade_rxd@ DB 'x:\github\re'
	DB	'negade\dragonade_rxd\scripts\commandlineparser.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OOHNGOIH@CommandLineParser?3?3CommandLinePa@
CONST	SEGMENT
??_C@_0CF@OOHNGOIH@CommandLineParser?3?3CommandLinePa@ DB 'CommandLinePar'
	DB	'ser::CommandLineParser', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1???0CommandLineParser@@QAE@PBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1???0CommandLineParser@@QAE@PBD@Z@4JA DD 011H ; `CommandLineParser::CommandLineParser'::`2'::__LINE__Var
_DATA	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4CommandLineParser@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CommandLineParser@@QAEAAV0@ABV0@@Z PROC		; CommandLineParser::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4CommandLineParser@@QAEAAV0@ABV0@@Z ENDP		; CommandLineParser::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File x:\github\renegade\dragonade_rxd\scripts\commandlineparser.cpp
;	COMDAT ?getDouble@CommandLineParser@@QAENXZ
_TEXT	SEGMENT
_string$ = -8						; size = 4
_this$ = -4						; size = 4
?getDouble@CommandLineParser@@QAENXZ PROC		; CommandLineParser::getDouble, COMDAT
; _this$ = ecx

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 	// Get the string if possible
; 108  : 	const char* string = getString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getString@CommandLineParser@@QAEPBDXZ	; CommandLineParser::getString
	mov	DWORD PTR _string$[ebp], eax

; 109  : 	if (!string)

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN1@getDouble

; 110  : 		return 0;

	fldz
	jmp	SHORT $LN2@getDouble
$LN1@getDouble:

; 111  : 
; 112  : 	// Return the converted string
; 113  : 	return atof(string);

	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	DWORD PTR __imp__atof
	add	esp, 4
$LN2@getDouble:

; 114  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getDouble@CommandLineParser@@QAENXZ ENDP		; CommandLineParser::getDouble
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File x:\github\renegade\dragonade_rxd\scripts\commandlineparser.cpp
;	COMDAT ?getInt@CommandLineParser@@QAEHXZ
_TEXT	SEGMENT
_s$1 = -12						; size = 4
_string$ = -8						; size = 4
_this$ = -4						; size = 4
?getInt@CommandLineParser@@QAEHXZ PROC			; CommandLineParser::getInt, COMDAT
; _this$ = ecx

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	// Get the string if possible
; 92   : 	const char* string = getString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getString@CommandLineParser@@QAEPBDXZ	; CommandLineParser::getString
	mov	DWORD PTR _string$[ebp], eax

; 93   : 	if (!string)

	cmp	DWORD PTR _string$[ebp], 0
	jne	SHORT $LN6@getInt

; 94   : 		return -1;

	or	eax, -1
	jmp	SHORT $LN7@getInt
$LN6@getInt:

; 95   : 
; 96   : 	// Check whether the string is a valid number
; 97   : 	for (const char* s = string; *s != '\0'; ++s)

	mov	eax, DWORD PTR _string$[ebp]
	mov	DWORD PTR _s$1[ebp], eax
	jmp	SHORT $LN5@getInt
$LN4@getInt:
	mov	eax, DWORD PTR _s$1[ebp]
	add	eax, 1
	mov	DWORD PTR _s$1[ebp], eax
$LN5@getInt:
	mov	eax, DWORD PTR _s$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@getInt

; 98   : 		if (*s < '0' || *s > '9')

	mov	eax, DWORD PTR _s$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN1@getInt
	mov	eax, DWORD PTR _s$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jle	SHORT $LN2@getInt
$LN1@getInt:

; 99   : 			return -1;

	or	eax, -1
	jmp	SHORT $LN7@getInt
$LN2@getInt:

; 100  : 
; 101  : 	// Return the converted string
; 102  : 	return atoi(string);

	jmp	SHORT $LN4@getInt
$LN3@getInt:
	mov	eax, DWORD PTR _string$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
$LN7@getInt:

; 103  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getInt@CommandLineParser@@QAEHXZ ENDP			; CommandLineParser::getInt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File x:\github\renegade\dragonade_rxd\scripts\commandlineparser.cpp
;	COMDAT ?getRemainingString@CommandLineParser@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRemainingString@CommandLineParser@@QAEPBDXZ PROC	; CommandLineParser::getRemainingString, COMDAT
; _this$ = ecx

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 	// Skip whitespace and return if the command ends here
; 82   : 	if (!skipWhitespace())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipWhitespace@CommandLineParser@@AAE_NXZ ; CommandLineParser::skipWhitespace
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@getRemaini

; 83   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN2@getRemaini
$LN1@getRemaini:

; 84   : 
; 85   : 	// Return the string
; 86   : 	return commandIter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
$LN2@getRemaini:

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getRemainingString@CommandLineParser@@QAEPBDXZ ENDP	; CommandLineParser::getRemainingString
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File x:\github\renegade\dragonade_rxd\scripts\commandlineparser.cpp
;	COMDAT ?getString@CommandLineParser@@QAEPBDXZ
_TEXT	SEGMENT
_string$ = -8						; size = 4
_this$ = -4						; size = 4
?getString@CommandLineParser@@QAEPBDXZ PROC		; CommandLineParser::getString, COMDAT
; _this$ = ecx

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	// Skip whitespace and return if the command ends here
; 60   : 	if (!skipWhitespace())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipWhitespace@CommandLineParser@@AAE_NXZ ; CommandLineParser::skipWhitespace
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@getString

; 61   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@getString
$LN2@getString:

; 62   : 
; 63   : 	// Get the token starting at this position
; 64   : 	const char* string = commandIter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _string$[ebp], ecx

; 65   : 
; 66   : 	// Skip nonprintable characters
; 67   : 	skipToken();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipToken@CommandLineParser@@AAEXXZ	; CommandLineParser::skipToken

; 68   : 
; 69   : 	// If the current iterator does not point to the end of the string, end the string and increase the iterator pointer
; 70   : 	if (*commandIter != '\0')

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN1@getString

; 71   : 	{
; 72   : 		*commandIter++ = '\0';

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN1@getString:

; 73   : 	}
; 74   : 
; 75   : 	// Return the string
; 76   : 	return string;

	mov	eax, DWORD PTR _string$[ebp]
$LN3@getString:

; 77   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getString@CommandLineParser@@QAEPBDXZ ENDP		; CommandLineParser::getString
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File x:\github\renegade\dragonade_rxd\scripts\commandlineparser.cpp
;	COMDAT ?skip@CommandLineParser@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?skip@CommandLineParser@@QAEXXZ PROC			; CommandLineParser::skip, COMDAT
; _this$ = ecx

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 	skipWhitespace();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipWhitespace@CommandLineParser@@AAE_NXZ ; CommandLineParser::skipWhitespace

; 54   : 	skipToken();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipToken@CommandLineParser@@AAEXXZ	; CommandLineParser::skipToken

; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?skip@CommandLineParser@@QAEXXZ ENDP			; CommandLineParser::skip
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File x:\github\renegade\dragonade_rxd\scripts\commandlineparser.cpp
;	COMDAT ??1CommandLineParser@@QAE@XZ
_TEXT	SEGMENT
$T1 = -72						; size = 4
_this$ = -4						; size = 4
??1CommandLineParser@@QAE@XZ PROC			; CommandLineParser::~CommandLineParser, COMDAT
; _this$ = ecx

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 28   : 	// Free the buffer
; 29   : 	delete[] command;

	push	OFFSET ??_C@_0CG@EOBEJLIK@CommandLineParser?3?3?$HOCommandLineP@
	mov	eax, DWORD PTR ?__LINE__Var@?1???1CommandLineParser@@QAE@XZ@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DP@LNJJFPIC@x?3?2github?2renegade?2dragonade_rxd@
	call	?SetThreadTrackingInformation@@YAXPBDI0@Z ; SetThreadTrackingInformation
	add	esp, 12					; 0000000cH
	xor	ecx, ecx
	je	SHORT $LN4@CommandLin
	xor	edx, edx
	jne	SHORT $LN3@CommandLin
	mov	eax, DWORD PTR ?__LINE__Var@?1???1CommandLineParser@@QAE@XZ@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1HO@CLELPKJP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN3@CommandLin:
	jmp	SHORT $LN1@CommandLin
$LN4@CommandLin:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@CommandLin:

; 30   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CommandLineParser@@QAE@XZ ENDP			; CommandLineParser::~CommandLineParser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File x:\github\renegade\dragonade_rxd\scripts\commandlineparser.cpp
;	COMDAT ??0CommandLineParser@@QAE@PBD@Z
_TEXT	SEGMENT
tv78 = -92						; size = 4
tv138 = -85						; size = 1
tv88 = -85						; size = 1
tv135 = -84						; size = 4
tv87 = -84						; size = 4
tv132 = -80						; size = 4
tv86 = -80						; size = 4
tv84 = -76						; size = 4
tv82 = -76						; size = 4
$T1 = -72						; size = 4
_this$ = -4						; size = 4
__command$ = 8						; size = 4
??0CommandLineParser@@QAE@PBD@Z PROC			; CommandLineParser::CommandLineParser, COMDAT
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 18   : 	// Copy the command
; 19   : 	command = new char[strlen(_command) + 1];

	push	OFFSET ??_C@_0CF@OOHNGOIH@CommandLineParser?3?3CommandLinePa@
	mov	eax, DWORD PTR ?__LINE__Var@?1???0CommandLineParser@@QAE@PBD@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_0DP@LNJJFPIC@x?3?2github?2renegade?2dragonade_rxd@
	call	?SetThreadTrackingInformation@@YAXPBDI0@Z ; SetThreadTrackingInformation
	add	esp, 12					; 0000000cH
	xor	ecx, ecx
	je	SHORT $LN4@CommandLin
	xor	edx, edx
	jne	SHORT $LN3@CommandLin
	mov	eax, DWORD PTR ?__LINE__Var@?1???0CommandLineParser@@QAE@PBD@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1HO@CLELPKJP@?$AAx?$AA?3?$AA?2?$AAg?$AAi?$AAt?$AAh?$AAu?$AAb?$AA?2?$AAr?$AAe?$AAn?$AAe?$AAg?$AAa?$AAd?$AAe?$AA?2?$AAd?$AAr?$AAa?$AAg?$AAo?$AAn?$AAa?$AAd?$AAe?$AA_?$AAr?$AAx?$AAd@
	push	OFFSET ??_C@_1M@HLGKFCJM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?$AA@
	call	DWORD PTR __imp___wassert
	add	esp, 12					; 0000000cH
$LN3@CommandLin:
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN5@CommandLin
$LN4@CommandLin:
	mov	edx, DWORD PTR __command$[ebp]
	mov	DWORD PTR tv132[ebp], edx
	mov	eax, DWORD PTR tv132[ebp]
	add	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LL7@CommandLin:
	mov	ecx, DWORD PTR tv132[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv138[ebp], dl
	add	DWORD PTR tv132[ebp], 1
	cmp	BYTE PTR tv138[ebp], 0
	jne	SHORT $LL7@CommandLin
	mov	eax, DWORD PTR tv132[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	add	ecx, 1
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv82[ebp], edx
$LN5@CommandLin:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR [eax], ecx

; 20   : 	strcpy(command, _command);

	mov	eax, DWORD PTR __command$[ebp]
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv86[ebp], edx
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv87[ebp], eax
$LN6@CommandLin:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv88[ebp], dl
	mov	eax, DWORD PTR tv86[ebp]
	mov	cl, BYTE PTR tv88[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR tv84[ebp]
	add	edx, 1
	mov	DWORD PTR tv84[ebp], edx
	mov	eax, DWORD PTR tv86[ebp]
	add	eax, 1
	mov	DWORD PTR tv86[ebp], eax
	cmp	BYTE PTR tv88[ebp], 0
	jne	SHORT $LN6@CommandLin

; 21   : 
; 22   : 	// Set the current command iterator to the start of the buffer
; 23   : 	commandIter = command;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 24   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CommandLineParser@@QAE@PBD@Z ENDP			; CommandLineParser::CommandLineParser
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File x:\github\renegade\dragonade_rxd\scripts\commandlineparser.cpp
;	COMDAT ?skipToken@CommandLineParser@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?skipToken@CommandLineParser@@AAEXXZ PROC		; CommandLineParser::skipToken, COMDAT
; _this$ = ecx

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 	// Loop while the character is printing and not whitespace
; 47   : 	for (; *commandIter > ' '; commandIter++)

	jmp	SHORT $LN3@skipToken
$LN2@skipToken:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN3@skipToken:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jle	SHORT $LN4@skipToken

; 48   : 		;

	jmp	SHORT $LN2@skipToken
$LN4@skipToken:

; 49   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?skipToken@CommandLineParser@@AAEXXZ ENDP		; CommandLineParser::skipToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File x:\github\renegade\dragonade_rxd\scripts\commandlineparser.cpp
;	COMDAT ?skipWhitespace@CommandLineParser@@AAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?skipWhitespace@CommandLineParser@@AAE_NXZ PROC		; CommandLineParser::skipWhitespace, COMDAT
; _this$ = ecx

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 	// Loop while the character is non-printing or whitespace
; 35   : 	for (; *commandIter <= ' '; commandIter++)

	jmp	SHORT $LN4@skipWhites
$LN3@skipWhites:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN4@skipWhites:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jg	SHORT $LN2@skipWhites

; 36   : 	{
; 37   : 		// Return false if the end of the string was reached
; 38   : 		if (*commandIter == '\0')

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN1@skipWhites

; 39   : 			return false;

	xor	al, al
	jmp	SHORT $LN5@skipWhites
$LN1@skipWhites:

; 40   : 	}

	jmp	SHORT $LN3@skipWhites
$LN2@skipWhites:

; 41   : 	return true;

	mov	al, 1
$LN5@skipWhites:

; 42   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?skipWhitespace@CommandLineParser@@AAE_NXZ ENDP		; CommandLineParser::skipWhitespace
_TEXT	ENDS
END
